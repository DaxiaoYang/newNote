# Database System

[TOC]

课程概要：

- 关系型数据库

- 存储

- 执行

- 并发控制

- 数据恢复

- 分布式数据库

  



## Relational model



数据库：

Organized collection of inter-related data that models some aspects of out real world





数据模型

- **关系型**：绝大部分的DBMS都是

- key-value

- 图

- 文档

- 列式

- 数组/矩阵

  



关系模型是抽象 数据库实现是具体 两者分离开来了



关系与表对应

元组与一个行数据对应



关系代数：是基于集合运算

- 过滤：对行
- 投影：对列

- 交
- 并
- 差
- 乘积
- natural join





## Storage1

storage1和storage2回答的问题是：

> DBMS怎么用磁盘上的文件来表示数据库



存储主要关注的是可持久化设备-磁盘上的数据的存储



数据库管理系统需要进行的操作：磁盘与内存之间的IO



DBMS的存储管理器需要记录页中的数据以及空闲位置



页：大小固定的块，通常一个块只存储一种类型的数据：元组、日志、索引



堆文件：页的无序组合，用于定位一个页

实现：

- 链表：两个表头，分别指向空闲页与数据页
- 页目录：是一个特殊的页，存储了页的位置和页中空闲空间的大小



页的组成：

- 页头：记录元数据

  - 页大小
  - 校验和
  - 软件版本
  - 事务可见性

- 数据：两种方式

  - slotted pages：

    由槽数组（->增长） 元组（<-增长） 和空闲空间组成

    ![image-20210815072811667](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210815072811667.png)

  - log-structured：只记录修改数据的操作

    ![image-20210815072839433](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210815072839433.png)



元组的组成：头 + 数据

每个元组都有一个ID=page_id + slot



## Storage2

**数据表示**

元组的数据在存储文件中只是字节信息，需要另外的元信息才能将其解析出来



**两种工作场景**

OLTP：

- 大部分查询只影响某一个元组 对某个元组的增删查改
- 写比读多
- 重复的操作多
- 大部分业务系统刚开始都是这样的



OLAP：

- 读取的数据通常是一张大表的一部分属性
- 对数据进行聚合分析



**存储模型**

行式存储：

元组的所有属性都连续存储在一个页中

- 优点：插入 修改 删除快
- 缺点：当需要对表的一部分数据进行查询时 会将很多不需要的数据也扫描到 并加载到内存中



列式存储：

元组的单一个的属性连续存储在一个页中

- 优点：对只查询表的一部分数据很快 相同属性的数据放在一起方便压缩
- 缺点：查询某个元组的数据不快 修改 删除也不快 

实现：一个页中给当前属性分配的大小存储空间是等长的





## Buffer Pool

**Lock和Latch**

共同点：都是锁的概念

不同点：

- Lock针对的对象是数据库 表 元组这种逻辑上的概念 保证不受其他事务干扰

  需要支持回退

- Latch针对的对象是Buffer Pool中的内部结构 保证不受其他线程干扰

  不需要支持回退



**Buffer Pool**

相当于一个对磁盘中的页的数据的内存缓存

当查找某个页的时候会先查找buffer pool，未命中再去查盘

数据结构就是一个页大小内存块的数组



元数据：

- page table: page_id -> frame
- dirty-flag：当某个页被修改了 必须将修改写回磁盘
- pin counter：访问该frame的线程数 当counter>0 此页不能被替换出去



优化：

- 多个buffer pool 减少锁竞争 指定per transaction的替换策略 提高局部性
- 提前读 常用于顺序读页时
- 多个查询共享游标



分配策略

- 全局: 考虑所有的事务
- 局部：per transaction



**Replacement policy**

替换策略 当需要buffer pool中的frame不够用的时候

需要把页从内存替换出去 此时需要选择替换哪个页



需要达到的目标：

- 正确性：正在访问的页不能替换出去
- 精准性：替换出去的页不会很快地又被读回来(抖动)
- 用于实现策略的元数据不能太多



LRU

- 为每个页都维持了一个时间戳
- 选择移除时间戳最老的页 



CLOCK：LRU的近似

设置一个访问位有线程访问时置为1 meta-overhead少了

在一个循环队列（环）中扫描 遇1则置为0 遇0则移除



LRU和CLOCK缺点：

- 当有顺序读的查询时 缓存会被污染
- 没有利用DBMS掌握的其他信息来提示哪些页更重要



其他策略：

- LRU-K：利用最后K次引用的信息
- priority-hints: 利用事务告知的信息
- localization: 以单个transaction为单位作查询



### Buffer Pool Manger Lab

**Clock Replacement Policy**

1. 初始化时 没有可管理的页帧

2. 当有存在没有线程引用的frame时 添加进来

3. 将页帧加入到replacer或者中replacer中删除某个页 都是通过改变frame的一个标志位

4. 初始化时 hand指向id=0为frame

5. clock hand遍历frame时 需要检查 标志位：在不在replacer中 页帧需不需要加入replacer中 （最近没有线程引用它 那就修改它的标志位）

   

需要实现的方法：

- Victim(T*) 从当前clock hand位置出发 找到第一个再replacer中且引用标志位为false的的页帧 

  如果frame在replacer里面 但是ref flag为true 则置其ref flag为false

  clock hand只由该方法进行修改

- Pin(T) 当page被放到frame后触发 需将frame从replacer中去除

- Unpin(T) 当某个page的pin_count = 0时触发 需将该page所在的frame加入到replacer中

- Size()  replacer中存在的frame的数量



## Hashtables

**数据库中的数据结构**：

- 与系统相关的元信息
- 与存储相关的信息
- 临时数据结构：查询时临时创建的
- 表索引：用于帮助快速找到特定元组的



**哈希表** 

- 哈希函数：任意的Key -> 固定位数的整数
- 哈希策略：哈希碰撞时采取的行为：
  - 耗费时间：再执行一些操作 找到新的插入位置
  - 耗费空间：或者是扩充哈希表的空间



**哈希函数**

只需要关注速度和碰撞率 加密不需要考虑 因为是内部使用的数据

用XXXHash3



**静态哈希策略**





**动态哈希策略**





## TreeIndex1

**索引**

索引是数据库表中数据子集的一个副本，用于快速找到某个元组或者某个范围内的元组（相较于顺序扫描），索引中的数据需要随着表的数据同步更新

利弊：

- 利：方便了查询
- 弊：增加了存储和维护索引的成本



**B+树**

多路完美自平衡的查找树



**B+树设计**

- 节点大小

  读取速度越慢 节点的大小应该越大

  读取一个节点的时候是顺序读取

- 合并时机

  延迟平衡操作 可以减少维护索引的成本

- 变长key

  key数组里面存着偏移量 指向key-value的地方 slots

- key不唯一时

  就存重复的key

- 节点内部的查找

  一般是二分 因为是按key顺序排列的



**B+树优化**

- 前缀合并（用的比较多）

  将相同的前缀提取出来 不重复存储重复的部分

  因为相近的key存储在一起 

- 后缀去除

  索引的key只取一部分 不取全部的key

- 批量插入

  批量插入b+树时 不是一个一个的加进去 而是先排序 然后自底向上的生成一个树 然后再把这个小的树合并到大的树中



## TreeIndex2

**索引的其他用处**

- 隐性创建的索引

  主键约束和唯一性约束都会创建索引 要不然找重复的得顺序遍历全表

- 部分索引

  只对某些列的部分建立索引 减少建立和维护的成本

- 覆盖索引

  查找的字段从索引中就能找到 不用再去主表中查

- 加列索引

  索引中外加列的信息 达到覆盖索引的效果

- 索引是列的函数



**Radix Tree**

前缀树的一种，主要是从纵向压缩了存储



**反向索引**

又称为全文索引，建立字词到含有该字词的元组的映射



查询类型：

- 语句查找
- 近似词查找
- 通配符查找



设计：

- 存储什么：

  所有记录中出现的词

  词频、位置等其他元信息

- 何时更新：

  等累积到一定的修改量后，批量更新





## Index Concurrency Control

**并发安全两个层面**

- 逻辑正确：一个线程只能看到它允许被看到的数据
- 物理正确：内部数据结构的线程安全问题


**Lock 但 Latch的区别（在数据库系统中）**

- Lock
  - 保护索引的逻辑内容不受其他事务的影响
  - 持有时间是整个事务中
  - 需要支持回退变化
- Latch
  - 保护索引内部数据结构的临界去的线程安全
  - 持有时间是在操作过程中
  - 不需要支持回退 
  - 有两种模式：
    - 读锁：多个读锁之间不互斥
    - 写锁：写锁与写锁、读锁都互斥



**Latch的实现**

- 操作系统自带的futex

  先使用用户空间的自旋锁

  自旋锁失败后使用操作系统级的互斥量

- CAS

- 读写锁



**给哈希表加锁**

- 对页加锁
- 对slot加锁



**给B+树加锁**

**基本策略**

查找时：

1. 加读锁
2. 如果获取了孩子结点的读锁，就释放当前持有的结点的读锁



插入或删除时：

1. 加写锁
2. 从根结点开始 获取了孩子结点的锁后 判断孩子结点是否是安全的（即结点中值的个数可以承受住变化 不会影响到父结点的结果 插入时值少 删除时值多）
3. 如果是安全的则释放持有的所有父结点的写锁



**改进策略**

因为对于所有修改操作，都需要获取根结点的写锁，所以会影响并发度

所以采取乐观的态度，认为本次修改操作不会造成叶子结点的分裂或者合并，修改时从根结点到叶子结点的父节点一直获取读锁，如果发现叶子结点不是安全的，则回退到基本策略，从根结点开始获取写锁



**叶子结点扫描**

因为之前的所有线程的获取锁的方向都是从上到下，不会出现死锁的线程（T1有A的锁想要B，T2有B的锁想要A）

现在的扫描叶结点会有两个方向 -> <- 所以会造成死锁，所以线程需要在获取不到锁的时候立即释放掉自己以及获取的锁，然后重新操作（因为没有一个管理机制来进行死锁检测和消除死锁）





