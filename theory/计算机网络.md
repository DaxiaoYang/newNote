# 计算机网络

[TOC]

## HTTP协议



WWW构建技术：

- html作为传输介质
- http作为传输协议
- uri作为地址



**请求报文**：

- 请求方法
- 请求URI
- 协议版本
- 请求头
- 请求体

![image-20210922114159955](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210922114159955.png)



**响应报文**：

- 协议版本
- 状态码
- 状态码的原因短语
- 响应头
- 响应体

![image-20210922114317427](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210922114317427.png)



**HTTP方法**

> 用于告知服务器请求的意图

- GET：获取资源
- POST: 传输实体的主题
- PUT：传输文件
- HEAD：只获取响应报文的首部，用于确认URI的有效性和资源更新的日期
- DELETE：删除文件
- OPTIONS：查询服务器支持的方法
- TRACE: 追踪路径
- CONNECT：用隧道协议连接代理



**持久连接与流水线化**

建立一次TCP连接后，可以发送多次http请求，并且流水线的方式可以无需等待一个请求的回应就发送下一个请求

![image-20210922134715822](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210922134715822.png)



**状态管理**

http协议本身是无状态的，也就是说无法根据之前的状态对本次的请求进行处理，但是可以借用Cookie

Cookie使用流程：

1. 服务端在响应头中会加上`Set-Cookie`的字段，通知客户端保存Cookie
2. 客户端下次再往服务器发送请求时，会自动在请求报文的请求头中加上`Cookie`的值
3. 服务端接收到`Cookie`值后，解析与服务器中保存的信息比对 就可以知道客户端信息



**编码提升传输效率**

编码主体：服务端

解码主体：客户端

- 内容编码：对响应体进行压缩
- 分块传输编码：对响应体进行分块传输



**多部分对象集合**

> 用于发送多种数据

`Content-Type`字段：

- `multipart/form-data`

  Web表单上传文件时使用

- `multipart/byteranges`

  返回码为206(partial content) 响应报文包含了一个文件的多个范围的内容时使用

- `boundary`：用于划分集合中的对象

  ![image-20210922145028865](/Users/yangsiping/Library/Application Support/typora-user-images/image-20210922145028865.png)





**范围请求**

> 获取部分内容

使用场景：所请求的文件过大，一次下载一部分，下次从中断的地方下载

请求：

- 请求头：`Range`: bytes=-3000, 5001-10000

响应：

- 状态码: 206 partion Content

- 响应头：`Content-Type`: multipart/byteranges 如果是多重范围
- 如果无法响应范围请求，则会返回200和完整的文件



**内容协商**

使用场景：根据客户端语言，返回相应语言的页面

协商依据：

- `Accept`
- `Accept-Charset`
- `Accept-Encoding`
- `Accept-Language`
- `Content-Language`



**状态码**

|      | 类别          | 原因短语                     |
| ---- | ------------- | ---------------------------- |
| 1XX  | Informational | 接收的请求正在处理           |
| 2XX  | Success       | 请求正常处理完毕             |
| 3XX  | Redirection   | 还需要进行附加操作以完成请求 |
| 4XX  | Client Error  | 服务端无法处理请求           |
| 5XX  | Server Error  | 服务端处理请求出错           |



- 2XX

  表明请求被正常处理了

  - 200 OK：处理成功
  - 204 No Content: 请求处理成功，但不会返回响应体
  - 206 Partial Content：服务端返回了客户端的范围请求

- 3XX

  表明浏览器需要某些特殊的处理以正确处理请求

  - 301 Moved Permanently：所请求的资源已被分配了新的URI 用户需要将新的URI更新为书签

  - 302 Found：临时性重定向，用户仍然保留原来的URI

  - 303 See Other：临时性重定向，但是明确表明客户端应该用GET方法

  - 304 Not Modified：服务器端未满足请求中附带的条件，所以不返回响应体 与重定向无关

    请求头中有`If-xxxx` 比如`If-Modified-Since`

    > The **If-Modified-Since header** is a request-header that is sent to a server as a conditional request. If the contents have changed, the server responds with a 200 status code and the entire requested document is updated. The If-Modified-Since HTTP header indicates the time for which a browser first downloaded a resource from the server. This helps to determine whether the resource has changed or not, since the last time it was accessed. If the status of a particular resource is 304 Not Modified, this means that the file has not changed and there is no need to download it again.

  - 307 Temporary Redirect，临时重定向，遵照浏览器标准，重定向的请求不会从 POST 变成 GET

- 4XX

  表明客户端是发生错误的原因所在

  - 400 Bad Request：请求报文中存在语法错误
  - 401 Unauthorized：发送的请求需要有通过HTTP认证的认证信息
  - 403 Forbidden：不允许访问资源
  - 404 Not Found：服务器上无法找到请求的资源

- 5XX

  表明服务器本身发生错误

  - 500 Internal Server Error：表明服务器端在执行请求时发生了错误
  - 503 Service Unavailable：服务器处理超负载或停机维护中，无法处理请求





**三种客户端与服务器中的中介**

- 代理

  不改变URI和协议，可用对报文内容进行加工

  转发时加上Via:自己的主机信息

  作用：

  - 缓存，较少网络带宽的流量（浏览器自身也有缓存）
  - 访问控制
  - 获取访问日志

- 网关

  可以改变协议

- 隧道

  确保通信的安全





## HTTP/1.1协议

> a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems



**浏览器发起HTTP请求的典型场景**

1. 浏览器从URL中解析出域名
2. 拿域名去DNS 获取IP
3. 三次握手建立TCP连接
4. 构造并发送HTTP请求
5. 服务器返回html
6. 浏览器解析引擎解析html 并根据其中的超链接构造其他的HTTP请求



HTTP报文格式：

HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ]



**URI**

> URL：locator 表示资源的位置
>
> URN：name 某个资源的与位置无关的标识

URI：identifier 用以区分资源 是URL和URI的超集

- 统一：

  对不同种类的资源标识符可以使用同一种语义进行解读

- 资源：

  可以是实体 也可以是抽象的概念 例如关系

- 标识符：

  将当前资源与其他资源区分开的名称



**URI编码**

编码原因：URI中可能出现一些特殊字符 导致URI解析失败

特殊字符范围：

- 用作分隔符的保留字符
- 可能产生歧义的字符
  - 不在ACSII范围内的字符
  - ASCII范围内不可显示的字符
  - URI中规定的保留字符
  - 不安全字符：空格 引号 尖括号等

百分号编码：

- 方式：% hex hex

- 对非ASCII字符（如中文） 先UTF8 -> 再变成ASCII

- 对URI合法字符 编码与不编码等价

  URI <=> %55%52%49



### WebSocket协议

出现背景：

之前客户端获取服务端最新资源的方式：AJAX轮询

AJAX轮询的缺点：

- 请求间隔时间短，造成的网络和服务器压力大
- 请求间隔时间长，资源更新不及时



WebSocket：实现了服务器的推送，将TCP的双向通信的功能暴露给了应用层

优点：支持消息的及时推送

缺点：可伸缩性差，因为WebSocket Server维护了具体的连接，是一个有状态的服务，扩容的方案复杂，需要两层，多加一层消息分发消息，将将消息分发到无状态服务上

![image-20220616071721725](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202206160717844.png)



消息的组成：由一个或者多个数据帧组成

Frame数据帧：

- 持续帧：跟前面一个帧同样类型
- 文本帧 二进制帧



除此之外还有控制帧：带内信令

- 关闭
- ping
- pong





## 图解网络

### HTTP

主要内容：

- HTTP基本概念
- GET POST
- HTTP特性
- HTTP与HTTPS
- HTTP/1.1 HTTP/2 HTTP/3演变



**HTTP是什么**

超文本传输协议

- 超文本：文件 图片 视频 超链接
- 传输：**两点**之间进行传输 可以有中间代理人
- 协议：参与者之间的**行为约定和规范** 比如交通规则

> 在计算机世界中 专门在两点之间传输文字 图片 音频 视频 这些超文本数据的约定和规范





*HTTP基本知识*



**HTTP常见的状态码**

- 2XX 成功 报文已经收到并且被正确处理

  200 OK

  206 Partial Content 返回的数据是资源的一部分

- 3XX 重定向 资源位置变动 需要更改URL

  301 Moved Permanently 永久重定向 请求资源已经转移了

  302 Found 临时重定向 请求资源还在 但是暂时用另一个URL

  304 Not Modified 没有跳转的语义 表示资源未修改 重定向到客户端已存在的缓存文件 常与请求头`If-Modified-Since`搭配使用

  就是为了更好的利用缓存 如果缓存的数据没有变动 那就不需要传输

- 4XX 客户端发送过来的报文有误

  400 Bad Request 客户端请求报文有误

  403 Forbidden 服务器禁止访问资源

  404 Not Found 请求的资源在服务器上不存在

- 5XX

  500 Internal Server Error 服务器错误

  502 Bad Gateway 服务器自身正常 但是访问后端服务器发送错误

  503 Service Unavailable 服务器正忙 暂时无法响应

  

**HTTP常见的字段**

- Host：服务器域名或IP
- Content-Length：数据字节长度
- Connection：Keep-Alive 要求服务器使用TCP持久连接 以便复用其他请求
- Content-Type：数据格式



*GET和POST*

**GET和POST的区别**

- GET表示从服务器获取资源
- POST表示向指定URI提交数据 数据放在body中



**GET和POST方法都是安全和幂等的吗**

> 安全：不会破坏服务器上的资源
>
> 幂等：多次执行相同的操作 结果都是相同的（请求一次和请求多次造成的影响一样）

- GET是只读操作 不会更改资源 所以是安全和幂等的
- POST会修改服务器上的资源 所以是不安全的 且多次POST就会创建多个资源 所以不是幂等的



*HTTP特性*

**HTTP1.1的优点**

- 简单：header(key-value) + body
- 灵活和易于扩展：各个组成部分都可以自定义和扩充 
- 应用广泛和跨平台



**HTTP缺点**

- 无状态：服务器不会去记忆HTTP的状态 但是在完成一些具有关联性的操作时不方便 所以需要Cookie

- 明文传输：信息可直接阅读

- 不安全： 通过引入SSL/TLS层

  明文传输 内容可能被窃听

  无法验证对方的信息 是否是真的网站

  无法验证报文的完整性 内容可能已经篡改



**HTTP/1.1性能**

- 长连接 复用TCP连接（对象复用 均摊创建和销毁成本）相对于1.0而言
- 管道网络传输：客户端一个请求的响应还没回来就可以发下一个请求 但是服务器还是按照顺序处理请求 如果某个请求用时过长 就会造成队头阻塞（因为是同一个TCP连接）



*HTTP与HTTPS*

**HTTP与HTTPS区别**

- HTTP是明文传输 存在安全风险的问题，HTTPS在TCP和HTTP之间加入了SSL/TLS协议 使得报文加密传输
- 在TCP连接建立后 即可进行HTTP报文的传输 但HTTPS在TCP连接建立后 还需要进行SSL/TLS的握手
- 端口号不同
- HTTPS需要向CA申请数字证书 保证服务器身份是可信的



**HTTPS解决了HTTP存在的哪些问题**

- 窃听风险：信息加密
- 篡改风险：内容校验机制
- 冒充风险：身份证书



**HTTPS如何解决上面的三个风险**

- 混合加密 实现信息的机密性

  tradeoff：

  - 对称加密只使用一个密钥进行加解密 速度快
  - 非对称加密用两个密钥：公钥和私钥 解决了密钥交换问题 但是速度慢  

  通信前用非对称加密交换密钥

  通信中用密钥进行对称加密来加密明文数据

- 摘要算法 实现完整性 （对明文做哈希）

- 服务器公钥放入数字证书中

  客户端需要先向服务端请求公钥 但是公钥可能被篡改或者是不可信的 所以需要先将服务器公钥放在数字证书中 只要证书可信 公钥就可信

  ![image-20220304191624353](https://gitee.com/yang_siping/static/raw/master/image-20220304191624353.png)





**HTTPS的连接是怎么建立的**

TLS协议基本流程：

握手阶段为前两个：

1. 客户端向服务器索要并验证服务器公钥

2. 双方协商产生会话密钥

3. 双方使用会话密钥进行加密通信



详细流程：

1. ClientHello：客户端向服务器发起加密通信请求
   - 客户端支持的TLS版本
   - Client Random 随机数
   - 客户端支持的加密算法
2. ServerHello：
   - 确认TLS版本
   - Server Random 随机数
   - 确认加密算法
   - 服务器的数字证书（CA私钥加密后的服务器公钥）

3. 客户端回应

   通过浏览器或者操作系统中的CA公钥 来确定服务器数字证书的真实性 如果没问题 则从数字证书中取出服务器公钥 用服务器公钥加密报文

   - pre-master key 随机数
   - 加密算法改变 之后用对称加密
   - 客户端握手结束 同时将所有发生的数据做摘要 用于服务器校验

4. 服务端的最后回应

   - 加密算法改变
   - 服务端握手接收 数据做摘要 用于客户端校验

   会话密钥：client random + server random + per-master key 



*HTTP/1.1 HTTP/2 HTTP/3演变*

**HTTP1.1相比HTTP1.0做了什么优化**

优化：

- TCP长连接改善了HTTP1.0短连接造成的性能开销（复用）
- 支持管道网络传输 可以不必等待之前的请求返回就发送下一个请求（异步化）

不足：

- header数据没压缩
- 相同时间点内发送的请求头部会有重复的
- 队头阻塞 服务器的一个TCP连接 一次只能处理一个请求 之后的请求只能排队等着
- 没有请求优先级
- 请求只能从客户端开始 服务端只能被动响应



**HTTP/2相比于HTTP/1.1的优化**

优化：

- 头部压缩（加状态）

  HPACK：如果发现**同时**发出的多个请求的头是一样的 协议会消除重复的部分

  在两端都建立一张头信息的表 index -> key-value 如果之后有相同字段 就发送索引号

- 二进制格式

  取消了纯文本 头和数据体都采用了二进制 免去了之前将字符串明文转成二进制的消耗

- 数据流

  一个TCP连接可以有多个Stream 一个Stream中可以有多个消息 request  repsone  Message  Message由多个Frame构成 且Stream可以指定优先级

  每个请求或者响应都属于不同的Stream 不同Stream的frame可以并发 同一个Stream内部的Frame严格有序

- 多路复用

  一个连接中并发处理多个请求 而不用一个个按序处理

- 服务器推送

  服务器可以主动向客户端发送消息



不足：

多个HTTP复用一个TCP连接 如果TCP中有一个包丢了 那就需要等待这个包重传回来 才能继续发送HTTP请求 这样就阻塞了其他所有的HTTP请求



**HTTP/3相对于HTTP/2做的优化**

传输层换成了基于UDP的QUIC协议 就可以实现类似TCP的可靠性传输

- 丢包只会阻塞当前流 其他流不会受到影响
- TLS1.3 头部压缩算法用QPack
- 将TCP + TLS1.3的握手从6次合并成3次





### TCP

***三次握手与四次挥手***



**TCP基本认识**



*TCP头部*：

- 序列号：

  初始值为随机数  next  = SYN + 当前发送的数据的字节数 用来解决网络部乱序问题

- 确认应答号：

  表明希望接受这个号的数据  这个序列号之前的数据都已经被接收 用来解决丢包的问题 

- 控制位：

  - ACK： 1表示确认字段有效
  - RST：1表示TCP连接异常 强制断开连接
  - SYN：1表示希望建立连接
  - FIN：1表示之后不会再发送数据 但仍可以接收数据



*为什么需要TCP协议 TCP工作在哪一层？*

因为网络层的IP协议不可靠：best effort

- 不保证网络包的交付
- 不保证网络包的按序交付
- 不保证网络包数据的完整性

TCP是传输层的可靠数据传输协议，能确接收端接收到的网络包是无损坏、无间隔、非冗余和按序的



*什么是TCP*

TCP是面向连接的 可靠的基于字节流的传输层通信协议

- 面向连接：只能1对1
- 可靠：能保证一个报文一定能到达接收端 不管网络环境怎么样
- 字节流：消息没有边界 



*什么是TCP连接*

Socket(IP + port) + 序列号 + 窗口大小，用于保证可靠性和流量控制



*如何唯一确定一个TCP连接*

四元组：

- 源地址 ip头
- 源端口 tcp头
- 目的地址 ip头
- 目的端口 tcp头



*单机的TCP连接数的最大上限*

理论： 2^32(IPv4) * 2^16  

实际：

- 文件数限制：因为socket都是文件 所以linux下用户能打开的文件最大值会限制  `ulimit -n`
- 内存限制：每个TCP连接都会占用一定内存



*TCP和UDP区别 和应用场景*

区别：

- 传输前是否要建立连接
- 服务对象 1-1 1-n n-m
- 可靠性
- 流量控制和拥塞控制
- 首部开销
- 传输方式：
  - 流式
  - 一个包一个包的发

应用场景：

- TCP：
  - FTP
  - HTTP
- UDP：
  - DNS SNMP
  - 音频 视频
  - 广播通信



**TCP连接建立**

*TCP三次握手过程*

![image-20220305112837439](https://gitee.com/yang_siping/static/raw/master/image-20220305112837439.png)

> 注：第三次握手可以携带数据 前两次握手都只有头部信息



*linux系统中查看TCP状态*

![image-20220305113612139](https://gitee.com/yang_siping/static/raw/master/image-20220305113612139.png)



*为什么握手是3次 不是两次 四次*

- 可以避免历史连接触发的初始化（主要原因）

  情景：

  syn=90 syn=100 syn=90先到 服务端 服务端ack=91 

  到客户端这里发现跟最新的序列号对不上 所以在第三次握手的时候发送RST中断连接 

  如果对上了就发送ACK

  只有两次握手的话 客户端无法再连接时主动中止连接 重复建立连接也会导致资源浪费

- 同步双方的序列号

  双方互相确认对方收到了自己发出的序列号

  四次握手也可以同步序列号 但是服务端向客户端发送的ACK和SYN可以合并为一个

  

*MSS和MTU*

![image-20220305120513827](https://gitee.com/yang_siping/static/raw/master/image-20220305120513827.png)

IP层一个IP报文的长度>MTU时 就要进行分片 保证每个分片<MTU，当一个IP分片丢失 该报文的所有IP分片都需要重传 而IP自身没有重传机制 所以只能等TCP超时重传 

所以TCP层在发现数据会超过MSS时（也就是IP层会超过MTU）会自己进行分片 当一个TCP分片丢失时 只会重传那一个分片

MSS = MTU - IP头部 - TCP头部

1460 = 1500 - 20 - 20



*SYN攻击及避免方法*

攻击方式：

攻击者短时间内伪造大量不同的IP地址 发起SYN报文 服务器接收到过多的SYN报文就会占满服务端的SYN接收队列 影响正常服务



SYN队列与Accept队列

![image-20220305123222245](https://gitee.com/yang_siping/static/raw/master/image-20220305123222245.png)



> SYN请求过多会造成SYN队列满
>
> 应用处理速率小于连接建立速率 Accept队列就会满





避免方法：

当SYN队列满时 对该SYN请求返回一个cookie值 如果之后客户端有ACK过来时再校验ACK是否合法 合法就直接放到Accept队列中



**TCP连接断开**

*TCP四次挥手*

![image-20220305141614742](https://gitee.com/yang_siping/static/raw/master/image-20220305141614742.png)



> 注：主动关闭连接的才有TIME_WAIT



*为什么需要4次挥手*

因为服务端的在收到客户端的FIN后 先发应答ACK 但是可能还有数据需要处理和发送 等待数据发送完 再发一个FIN  ACK和FIN需要分开 所以比3次握手需要多一次



*为什么客户端TIME_WAIT的等待时间是2MSL*

> MSL：最大报文生存时间

如果被动关闭方没有接收到最后的ACK报文 那会超时重发FIN（自ACK发出已经1MSL） FIN到达主动关闭方又需要1MSL



*为什么需要TIME_WAIT状态*

- 防止接收到旧连接的数据包

  确保两个方向上的数据包都在网络中自然消失

- 保证连接正确关闭

  确保最后的ACK能被被动关闭方接收 帮助其正常关闭



 *服务器TIME_WAIT过多的危害*

说明是服务器主动断开的请求 

- 内存资源的占用
- 对端口资源的占用



*建立连接后客户端突然出现故障怎么办*

TCP有保活机制，如果一个时间段内容连接没有报文活动，则每隔一个时间段会发送一个探测报文

客户端情况：

- 客户端正常工作：正常响应 TCP保活时间重置
- 客户端重启：客户端发RST报文 重置TCP连接
- 客户端崩溃或其他原因不可达：TCP报告该连接已死亡





**Socket编程**

![image-20220305150714962](https://gitee.com/yang_siping/static/raw/master/image-20220305150714962.png)



监听socket和真正传输数据的socket是两个





***TCP 重传 滑动窗口 流量控制 拥塞控制***



*重传机制*

序列号 + 确认应答

- 超时重传：数据包丢或者响应报文丢

  超时时间（RTO 是根据RTT动态变化的）应略大于1RTT

- 快速重传：发送方收到相同的ACK直接重发

- SACK：接收方告知发送方自己已经收到的报文序列

- D-SACK：告知发送方有哪些数据被重复接收了 让发送方更了解网络情况



*滑动窗口*

窗口：未收到ACK前 可以继续发送的数据的最大值

TCP头部字段 `Window` 用来帮助接收方告诉发送方自己还有多少缓冲区可以接收数据



*流量控制*

发送方根据接收方的实际接收能力控制发送的数据量



*拥塞控制*

避免给网络添堵 根据网络情况动态调整发送方的发送数据

只要发生了超时重传就认为当前网络出现了拥塞



拥塞控制算法：

- 慢启动：每收到一个ACK cwnd++ (cwnd < ssthreshold)

- 拥塞避免：一个ACK cwnd += 1/cwnd  即线性增长

- 拥塞发生：当出现重传现象时启用

  - 超时重传：ssthresh = cwnd / 2  cwnd = 1（重新退回到慢启动）因为出现丢包就认为网络拥堵很严重了 需要立即降低发送速率

  - 快速重传：cwnd = cwnd / 2 ssthresh = cwnd 窗口减半 （网络拥堵状况不是很严重 因为只丢了一部分报文）

    然后进入快速恢复

- 快速恢复

  cwnd = ssthresh + 3 然后开始线性增长







### IP

*IP基本认识*

**IP的作用**

负责主机到主键的通信



**IP与MAC**

IP负责在没有直连的两个网络之间进行通信

MAC负责在同一个网络中的直连的两个设备之间的通信



*IP地址的基础知识*

**IP地址的定义**

IP地址由int32表示 表示方式是8bit一组 表示成10进制



**IP地址分类**

A B C：网络号 + 主机号（划分固定） 第 1 2 3位bit为0

D：多播地址



**无分类地址**

自由划分网络号和主机号

区分网络号和主机号的原因：

如果发送的目的IP跟源IP在同一个网络 则不需要走路由器 直接发送

子网掩码还可以进一步对主机号进行划分：主机号 = 子网网络地址 + 子网主机地址



**公有IP地址和私有IP地址**

私有IP可以自己随便分配

公有IP -NAT-> 私有IP

公有IP需要申请



**IP地址与路由控制**

主机和路由器都有自己的路由器控制表 网络地址主要用来进行路由控制 

匹配 -> 选择下一个结点



**IP分片与重组**

以太网MTU=1500B 就是的数据范围的最大大小 

IP包 > MTU 传输时就需要被分片 然后在目标主机重组

一个分片丢失 整个IP数据包就作废（IP层没有确认重传机制 best effort）



**IPv6基本认识**

128bit



*IP协议相关技术*

**DNS**

域名解析的流程：

1. 浏览器缓存
2. 操作系统缓存
3. 域名解析文件: hosts
4. DNS服务器（只指路不带路）
   1. DNS客户端 -> 本地DNS（TCP/IP设置中填写的）
   2. 根（指出一条明路）
   3. 顶级 .com
   4. 权威 server.com



**ARP**

找到下一跳的MAC地址

在同一个中发送ARP广播 接收到的主机或路由器 判断IP是不是自己的  如果是就发送MAC地址回去

> RARP MAC -> IP 嵌入式设备接入网络时用到



**DHCP**

动态获取IP

1. 客户端UDP广播
2. 服务器UDP广播（因为此时客户端还没有IP地址）
3. 客户端 选择一个 发送请求（因为可能收到多个）
4. 服务端 ACK



**NAT**

私有地址 -> 公有地址 + 端口



**ICMP**

- 查询报文：Ping使用的就是这个
- 差错报文：报告IP包在传输过程中遇到的问题：如目的主机不可达



**输入网址到网页显示的过程**

1. 解析URL 生成http请求报文
2. 域名 -> IP 查缓存或者DNS服务器
3. ↓ 加上TCP头部 确定端口 目标进程 传输数据前 3次握手建立连接
4. ↓ 加上IP头部 确定主机 
5. ↓ 加上MAC头部 确定同一网络内的下一站地址（目的MAC地址 通过ARP获取 IP -> MAC）
6. 网卡 头尾都加信息 数字信号 -> 电信号
7. 交换机根据目的MAC地址 查MAC->网线端口的映射表 转发包
8. 路由器 其端口有MAC地址也有IP地址 与计算机的网卡一致 查路由表 转发包(此时需要变源MAC地址和目的MAC地址 因为跨网络了)
9. 到达目的主机后 
   1. 剥离MAC头部 
   2. ↑ 剥离IP头部
   3. ↑ 剥离TCP头部
   4. ↑ 发给HTTP进程
   5. 处理请求 生成HTTP响应报文 发回去
10. 响应回到源主机后 剥到只剩HTTP响应报文 交给浏览器渲染页面
11. TCP四次挥手



**Linux系统如何收发网络包**

- 接收网络包
  1. 网卡接收到多个网络包时 才会触发一次中断 此时网络包已被拷贝到内核缓冲区中（网卡 - DMA-> Ring Buffer -> 内核缓冲区sk_buff）
  2. 网络接口层 校验
  3. 网络层 确认是转发还是交给上层处理
  4. 传输层 根据 四元组 IP:port IP:port 把数据放到对应的Socket的接收缓冲区
  5. 应用层 调用Socket接口 从内核的Socket接收缓冲区读取数据

- 发送网络包
  1. 应用程序调用Socket发送接口 Socket层会将应用层数据拷贝到Socket的发送缓冲区中
  2. 网络协议栈从Socket发送缓冲区取出数据包
  3. 传输层 增加TCP头（根据传输层协议 也可能是UDP头）
  4. 网络层 增加IP头
  5. 网络接口层 根据 ARP获取MAC地址 增加帧头 帧尾 放到发包队列
  6. 触发软中断通知网卡驱动程序 
  7. 驱动程序通过DMA 将网络包从发包队列放到硬件网卡的队列中
  8. 网卡发送包





## 图解HTTP



### 与HTTP协作的Web服务器

> 一个Web服务器可以对应多个域名 也可以作为中转服务器

- 虚拟主机：多个域名可以对应同一个HTTP服务器 所以HTTP请求中的Host字段要指定域名 HTTP才能知道是转发到哪个处理模块

- 转发相关：代理、网关、隧道

  - 代理：将请求转发给服务端 将响应转发回客户端

    协议：代理转发时会加上Via首部信息 还是HTTP协议

    使用场景：

    - 缓存资源
    - 访问控制 记录访问日志

  - 网关：转发客户端请求到服务器上

    协议：网关与后面的服务器通信可以使用其他协议（RPC）

  - 隧道：保持客户端和服务端双方的通信连接

    类似于加一层TLS 保证通信的安全性

- 保存资源的缓存：过期后会再次请求
  - 缓存服务器
  - 客户端缓存



### 确保Web安全的HTTPS

http存在的不足：（其他未加密的协议中也会有这类问题）

- 通信使用明文，内容可能被窃听

  方法：

  - 通信加密：TLS
  - 内容加密：只对报文主体部分进行加密

- 不验证通信方的身份（客户端或者服务端），可能遭遇伪装

  问题：

  - 请求的Web服务器可能是伪装的
  - 响应返回到的客户端可能是伪装的

  方法：通过确认第三方机构颁发的证书 来证明服务端或客户端的合法性

- 无法验证报文的完整性，内容有可能被篡改（请求或者响应的内容）

  方法：

  - 只用哈希：哈希值也可以被篡改
  - TLS中提供的摘要功能结合其他部分





HTTPS = HTTP + 加密 + 认证 + 完整性保护

![image-20220408071244805](https://gitee.com/yang_siping/static/raw/master/image-20220408071244805.png)



加密：

混合加密：非对称加密 + 对称加密（加解密速度快）

单使用对称加密存在的问题：对称加密加解密是同一个密钥，但是密钥传递的安全性无法保证

所以引入了非对称加密：用服务器公钥加密密钥 传递到服务器方 服务器用私钥进行解密 获取对称加密的密钥（根据密文和公钥进行解密的成本很大）

伪造问题：无法证明服务器公钥的正确性（有可能在传输过程中被替换掉了 然后客户端就会与攻击者的服务端建立SSL连接）



证书的引入：

- 由数字证书认证机构来给服务器公钥做签名 
- 证明服务端或客户端的真实性

服务器会发送公钥证书发给客户端 公钥证书 = 服务器公钥 + CA私钥对服务器公钥做的签名

客户端收到后用CA的公钥验证签名 验证通过后就能说明服务器的公开密钥是值得信赖的（常用CA的公钥是在浏览器发布时直接植入浏览器内的）



报文摘要：应用层发送数据时会添加一个摘要（Message Authentication Code） 保证完整性



SSL4次握手过程

1. ClientHello：客户端支持的SSL版本 和 加密组件（算法 + 密钥长度）
2. ServerHello：
   - 选择的SSL版本和加密组件
   - 公开密钥证书

3. Client Key Exchange：

   包含用服务端公钥加密的对称加密的密钥

   通知服务器之后的通信会用该密钥进行加密

4. Change Cipher Spec：服务端也表示之后的通信会用该密钥加密



SSL的问题：

HTTPS会比HTTP慢 2-100倍 慢的原因主要由于需要额外的SSL握手和加解密操作



### 确认访问用户身份的认证

场景：特定的Web页面只想让特定的人浏览

HTTP的认证方式

- BASIC认证（基本认证）

  请求头Authorization：base64(username:password)

  问题：

  - 可以直接解码 安全性差
  - 浏览器无法实现认证注销

- DIGEST认证（摘要认证）

  认证客户端使用的是由从服务端返回的质询码以及对内容的摘要

  问题：

  - 不存在防止伪装用户的机制
  - 安全等级低

- SSL客户端认证：客户端证书（认证客户端计算机） + 表单密码（认证本人）

  问题：客户端证书需要购买

- FormBase认证（基于表单认证）

  一般用Cookie来管理Session(会话)

  保存密码： 原始面貌加盐后hash

  

### 基于HTTP功能的追加协议

SPDY

> HTTP的性能问题：1.1版本
>
> - 请求只能从客户端开始
> - 头没有压缩且发送的头会有很多重复的数据
> -  数据部分没有强制压缩
>
> 
>
> 场景：服务端内容更新时 需要尽可能实时地将内容反馈到客户端界面上
>
> 之前的解决方案：都未解决HTTP协议本身存在的问题
>
> - Ajax：只更新局部页面
> - Comet：客户端发起请求后 如果服务端没有数据更新 则不会立即响应 直到等到有数据更新了 才会返回相应

SPDY: 会话层

![image-20220412084358542](/Users/yangsiping/Library/Application Support/typora-user-images/image-20220412084358542.png)

SPDY带来的功能：

- 多路复用流：一个TCP连接 可以无限制处理多个HTTP请求
- 可以给请求分配优先级
- 压缩HTTP首部
- 支持服务器向客户端推送数据的功能
- 服务器可以主动提示客户端请求所需的资源

问题：

- 需要Web浏览器和Web服务器配合改动
- 只是将单个IP的通信多路复用 一个Web需要使用多个IP返回的资源时 效果不佳


WebSocket

> RFC 6455
>
> 即Web浏览器与Web服务器之间的全双工通信标准

连接建立：

HTTP连接建立后 还需要一次请求和响应 建立WebSocket通信

- 请求：Upgrade:websocket 告知服务器通信协议发生变化
- 响应：101 Switching Protocols 

特点：

- 服务器向客户端推送数据的功能（TCP本来就是全双工）
- 连接状态更持久，建立连接的开销平摊到每次数据传输的成本更小，传输时的首部信息很小



HTTP2.0

- 头部压缩 双方都会维护一个头部表 之后遇到相同的只传索引就行
- 首部和数据部分都用二进制传输
- 将传输分为不同的数据流 可以给数据流指定优先级
- 多路复用 一个连接可以并发处理多个请求
- 服务器推送的功能



WebDAV

可以直接对Web服务器上的文件进行操作 

提供了创建 删除文件 对文件加锁 对文件内容修改的版本控制



### Web的攻击技术

Web站点受到攻击的原因：需要自行开发设计认证和会话管理功能



攻击模式：

- 主动：攻击者直接访问Web应用 并将攻击代码传入 SQL注入 OS命令注入
- 被动：诱使浏览器触发恶意的HTTP请求



## TCP/IP详解

### 概述

**分层**：是垂直方向的功能的解耦

- 应用层：处理特定的应用程序细节 
- 传输层：为应用程序提供端到端的通信
- 网络层：处理分组再网络中的活动
- 网络接口层：包括操作系统中的设备驱动和网卡 处理与物理传输介质的接口细节

> 应用层运行在用户态 以下层的都运行在内核态 处理通信细节
>
> 传输层和网络层分开的原因：
>
> 应用层和传输层是end-to-end协议 只有通信两端会用到
>
> 网络层是hop-by-hop 每一跳都要用到

**分用**：目的主机接收到一个以太网帧的时候 数据从协议栈自下而上 同时不断去掉各层协议加的报文首部 并根据首部中的协议标识 来确定要分发到哪一个上层协议

![image-20220417071109922](https://gitee.com/yang_siping/static/raw/master/image-20220417071109922.png)



### 链路层

作用：为3个上层协议服务

- IP
- ARP
- RARP



以太网的帧格式

- 目的地址: 6B
- 源地址:6B
- 类型:2B
- 数据:46-1500B (=> MTU=1500)
- CRC:4B



SLIP和PPP都是用来做两个主机之间的串行通信，都实现了压缩交互中不常变化的公共字段的方式来减少负载（HTTP2.0）



**环回接口**：运行同一台主机的客户端程序与服务端程序进行TCP/IP通信

![image-20220418072213956](https://gitee.com/yang_siping/static/raw/master/image-20220418072213956.png)

环回接口接收的数据

- 传给127.0.0.1的数据
- 发送广播和多播的数据（发送前先复制一份发给自己）
- 传给该主机IP的数据



**MTU**

最大传输单元，即MAC帧中的数据部分的最大字节数

如果IP数据报的长度 > MTU 则需要进行IP分片 使得每一片大小<=MTU

路径MTU：两个主机通信经过的网络中的最小MTU（瓶颈 也会是动态变化的）



### IP：网际协议

数据部分可以为TCP UDP ICMP IGMP

特点：

- 不可靠：不能保证IP数据包成功按序到达
- 无连接：每个数据包的处理都是相互独立的 每个包会独立选择路由



**IP首部**

![image-20220418081306251](https://gitee.com/yang_siping/static/raw/master/image-20220418081306251.png)

- 协议版本号：4
- 首部长度：单位为4B
- 服务类型：大多数实现都不支持TOS特性
- 总长度：字节 如IP数据包<46 则会进行填充 如果没有总长度 就不知道46个字节的哪个部分是IP数据报
- 标识：唯一标识主机发送的每一份数据报
- 标志 + 片偏移：IP分片和重组相关
- TTL：报文最多经历的路由器数量 过一个就-1 到达0时发送ICMP报文给源主机
- 协议：用于分用 
- 首部检验和：只检验首部字段
- 源IP
- 目的IP



**IP路由选择**

目的：根据目的IP在路由表中找到下一跳路由器的地址

原理：如果目的主机和源主机在同一个网络（以太网或其他网）内，IP数据包就直接送到目的主机上，否则发往默认路由，由路由器转发数据报

> MAC地址在经过不同网络时会变 但是IP地址不会变



过程：

1. IP层接收到一个数据报
2. 判断目的IP地址是否为本机IP地址或广播地址 如果是则分用到上层进行处理
3. 如果不是 则判断本机是否被设置为路由器 如果不是则丢弃 
4. 如果被设置为路由器 则搜索内存中的路由表 匹配内容进行转发



路由表内容：

- 目的IP地址：网络地址或主机地址
- 下一个路由器地址
- 标志
- 转发出去的接口



IO路由需要做的事情：

1. 在路由表中找到与目的IP完全匹配的项
2. 找与目的IP的网络号匹配的项
3. 找默认路由
4. 都找不到发送ICMP报文 传给源主机 告知网络不可达



### ARP：地址解析协议

> 32bit的IP -> 48bit的MAC

发送ftp请求步骤：ftp bsdi(主机名)

1. DNS：bsdi -> IP
2. 用IP地址作为目的地址 建立TCP连接
3. 发送TCP连接请求 发送一份IP数据报
4. 确定目的地址在本地网络还是在其他网络 获取下一站IP
5. ARP：IP -> MAC（内核实现）
6. 发送IP数据报到目的主机（链路层） 



ARP步骤：

1. 现在ARP缓存中找对应映射 缓存有自己的过期时间

2. 找不到 发送ARP请求 这是一个广播（主机号全为1）

   内容包含目的主机的IP 

   目的主机的ARP层收到这个广播报文后 识别出是自己的IP地址（默认网关应该也会发一个ARP应答）

   就会发送一个ARP应答（单播） 包含自己的IP地址和对应的MAC地址

3. 源主机收到应答后将结果缓存起来 `arp - a` 查询所有ARP高速缓存



免费ARP：自己已有IP 但是发送ARP请求在网络中找相同IP

作用：

- 确认是否有是否同一个网络上有相同的IP
- 通过广播 通知其他主机更新高速缓存中的对应值



### RARP：逆地址解析协议

> IP地址一般存储在磁盘的配置文件中 但是有的机器没有磁盘 所以需要通过其他方式来获取IP
>
> 每个机器的MAC地址是唯一的

也是广播 + 单播

RARP服务器是应用程序 一个网络中通常要有多个RARP服务器（容灾备份）无盘系统会采用最先到达的RARP应答





### ICMP：网络控制报文协议

用IP数据报进行传递 放在IP报文的数据部分

有两大类：

- 查询
- 差错

![image-20220423072353228](https://gitee.com/yang_siping/static/raw/master/image-20220423072353228.png)·

ICMP报文内容：都是为分用进行服务

- IP首部：有协议字段 用于确定上层协议
- 产生错误的IP包的前8个字节：有源端口号 用于确定用户进程



不会产生ICMP差错报文的场景：主要是为了避免广播风暴

- ICMP差错报文（查询会产生）
- 目的地址为广播地址或多播地址
- 不是IP分片的第一片
- 源地址不为单个主机的地址



用途：

- 无盘系统在引导时获取自己的子网掩码 会发送ICMP广播

- 查询另一个系统的当前时间

  标识符（区别用户进程 实现直接就是用的进程号） + 序列号（区别包）

- 判断端口是否可达



### Ping程序

功能：测试当前主机与另一台主机在IP层的联通性

组成：ICMP回显请求 + 回显应答（内核直接支持）

报文格式中的关键部分：

- 类型 + 代码
- 标识符：用户进程号
- 序号：每次都从0开始 用于查看IP报文的丢失 失序 重复

```shell
# ping 的 tcpdump  
# sudo tcpdump -i any host 110.242.68.3
08:08:53.266356 IP localhost > 110.242.68.3: ICMP echo request, id 28313, seq 0, length 64
08:08:53.327256 IP 110.242.68.3 > localhost: ICMP echo reply, id 28313, seq 0, length 64
```



其他可选的功能：

- 记录路由：`ping -R host`

  经过的中间路由器将出口的IP地址放入一个list中(源主机收到应答时 放入主机的入口IP) 

  list存放在IP首部 

  目的主机再将list加到应答中 

  问题：IP首部长度有限制 所以也限制了能存放的IP

  IP首部最长为 15 * 4 = 60B 固定需要用20B RR选项字段需要用3B

  所以只剩37B -> 9个IP地址（一个IP地址4B）

- 记录时间戳：

  需要同时记录路由中的IP地址(4B)和时间戳(4B)



### Traceroute程序

目的：可以让我们看到IP数据报的路由路径

出现背景：IP路由选项具有缺点

- 需要中间路径上的所有路由器都支持该选项（traceroute只需要目的主机支持UDP分用）
- 记录的一般是单向的出口地址 一来一回 记录的IP地址会翻倍（traceroute是记录到达的接口IP地址）
- IP首部中留给选项的空间有限 最多只能存放9个IP地址

原理：ICMPTTL=0差错报文(控制TTL数量实现) + ICMP端口不可达报文（UDP数据报实现）

迭代式的探测

TTL = 1 2 3 4...

收到的

source -> a -> b -> c -> d

a收到报文后TTL-1发现为0 往源主机发送ICMP超时报文

b c同理

d收到TTL=1的报文时 不会丢弃 因为已经到达目的主机 但是源主机发送的是一个UDP数据报 选择的是一个不可能存在的目的端口（>30000）所以目的主机会发送端口不可达错误的ICMP报文



IP原站选路选项：由发送者指定路由

- 严格模式：必须按照源主机指定的路由路径进行转发 如果转发失败 就返回源站路由失败的ICMP报文
- 宽松模式：源主机给的路由路径只是一个建议



### IP选路

> 作用：当需要转发IP数据报时 搜索路由表 并决定向哪个网络接口转发分组（选路机制）
>
> 需要主机有两个以上的接口 且设置为路由器才能转发数据报



IP层工作流程

![image-20220501062306223](https://gitee.com/yang_siping/static/raw/master/image-20220501062306223.png)



`netstat -r`：打印路由表 每个接口都有自己的子网掩码

```shell
Internet:
Destination        Gateway            Flags        Netif Expire
default            192.168.31.1       UGSc           en0       
1                  26.26.26.1         UGSc         utun2       
2/7                26.26.26.1         UGSc         utun2       
4/6                26.26.26.1         UGSc         utun2       
8/5                26.26.26.1         UGSc         utun2       
16/4               26.26.26.1         UGSc         utun2       
26.26.26.1         26.26.26.1         UH           utun2
```

Flags含义：

- U：路由可用
- G：存在就表示到达的是一个路由器 不存在则表明与目的地是直接相连的 不存在中间路由器
- H：有表示路由到一个主机 没有表示路由到一个网络（主机号全为0）
- DM：表示路由由ICMP重定向报文创建或修改



在路由表中的搜索次序：

1. 主机地址：需要完全匹配
2. 网络地址：掩码相与后的部分匹配 多个匹配的选最长的
3. 默认路由
4. 匹配不到 且没有配默认路由的情况下 给源主机发送ICMP路由不可达报文



ICMP重定向报文：

> 自适应修改路由的一种方式

![image-20220501070707154](https://gitee.com/yang_siping/static/raw/master/image-20220501070707154.png)

主机发送报文到默认网关R1（主机通常会在配置文件/etc/... 中配置默认网关），R1发现下一站是R2，且出口和入口相同，说明主机 R1 R2在同一个局域网，于是发送ICMP重定向报文给主机 告诉这个目的地址的下一站应为R2 而不是R1 从而减少网络中不必要的转发



ICMP路由器发现报文：

- 主机：在初始化时通过广播或者多播发送路由器请求报文 由局域网中的一台或多态路由器响应路由器通告报文
- 路由器：随机（为了减少与子网上其他路由器的冲突 路由表写操作应该会加锁）广播或者多播传送路由器通告报文



### 动态选路协议

> 作用：路由器之间互相告知路由信息 以更新自己的路由表

自治系统内的路由器的选路协议：IGP 

- RIP：基于跳数

  触发路由更新的时间点：

  - 路由守护进程初始化时 

    遍历所有接口 并在每个接口上发送请求报文（可以是广播）接收到请求的路由器回应报文 传回部分或全部地址 接收到相应后更新路由表

  - 定期同步完全路由信息给相邻路由器
  - 当一条路由的度量发送变化时 只发送变化的表项给相邻路由器

- OSPF：基于链路状态 主动探测与邻站的链路状态 并将这些信息发送给其他邻站

  优点：

  - 当同一个目的地址 存在多个可用的相同费用的路由时 可以进行流量平衡（负载均衡）
  - 采用多播 而不是广播 减少了网络负担 

跨自治系统的路由器的选路协议：BGP



CIDR：

基于32bit IP地址的掩码操作来进行选路决策 不区分A B C类地址

可以显著减少路由表中的表项（IP高位bit相同） 将多个表项合为一个



### UDP：用户数据报协议



> IP数据报和IP分片：
>
> IP数据报是IP层端到端的传输单位（水平的）
>
> IP分组是IP层和数据链路层的传输单位（垂直的）
>
> 一个分组可以是一个完整的数据报 也可以是数据报中的一个分片

![image-20220502075035278](https://gitee.com/yang_siping/static/raw/master/image-20220502075035278.png)



IP分片：

- 分片原因：因为数据链路层对传输的数据的最大长度有限制（MTU）
- 分片步骤：
  1. 发送IP数据报时 根据要发出的接口 查询出该接口对应的LAN的MTU 
  2. 将IP数据报的长度与MTU进行比较 如果大于 则需要进行分片
  3. 再根据IP首部中 是否允许分片标志 如果需要分片 但是不允许分片 则丢弃该报文 并向源主机发送ICMP不可达差错
  4. 如果需要分片且 允许分片 则将IP数据报进行分片 分为多个分组 每个分组独立选择路由 在目的主机被组装起来 
- 分片特点：
  - 一个分组丢失了 也要重传数据报的所有分组（IP层没有超时重传机制）
  - 分片有可能在中间路由器进行
  - 只有第一个分片有UDP首部



### 广播和多播

> 只有UDP能使用 TCP是点对点的

广播：一个主机向局域网中的其他主机（包括自身）发送帧

多播：一个主机向属于多播组的多个主机发送帧



协议栈接收一个帧的过程：（自下而上）

每一层都承担一定的过滤功能 

- 网卡 ：检查帧的检验和
- 设备驱动程序：检查协议（IP ARP） 判断多播组
- IP：检查源地址 目的地址
- UDP：检查源端口 目的端口 UDP检验和



多播优于广播的原因：

减少对该帧不感兴趣的主机的处理负荷，如UDP广播，接收到的主机需要到UDP层才会被丢弃 



发送广播的方式：

- 只能发送到本地网络的广播： `255.255.255.255`
- 指向网络的广播：网络号 + 主机号全为1
- 指向子网的广播：网络号 + 子网号 + 剩下的主机号全为1



多播使用场景：

- 向多个目的地址发送数据（多个copy）
- 客户对服务器的请求 之前用广播 使用多播可以降低不提供服务的主机的负担（网卡->驱动->IP->UDP）



多播地址：

4bit标识(1110) + 多播组ID(低28位)



多播的缺陷：多个多播地址 可能映射到同一个MAC地址(低23位对应) 因此需要设备驱动程序或IP层 进行进一步的过滤



多播的发送：

- 单个网络内：多播地址 -> MAC地址 直接发送就行
- 跨网络时：需要让多播路由器指定该多播组下的所有主机（IGMP）



### IGMP：Internet组管理协议

目的：让多播路由器知道其相连的网络中的多播组成员



多播路由器的每个接口都需要维护一个表，记录

多播组地址->主机

表的维护：

- 主机（中的一个进程）加入多播组时 发送IGMP报告
- 主机离开多播组时 不需要发送报告 由多播路由器定时轮询 向在表中的主机发送IGMP查询 如果收不到响应 就将主机删掉



所有主机组：`224.0.0.1` 一个物理网络中所有具备多播能力的主机和路由器在接口初始化时 都自动加入这个多播组 无需发送IGMP报告



### DNS：域名系统

DNS：是一个分布式数据库

客户端：地址解析器

- IP -> hostname
- hostname -> IP

服务端：名字服务器（内含有高速缓存）





域名格式：第二级域.顶级域 



某个区域内的名字服务器设计：主备

主：负责从磁盘文件中读入该区域的所有信息（hostname -> IP）

备：负责从主服务器同步信息



主机加入到某个区域的流程：

1. 将映射信息放到主服务器的磁盘文件中 并通知主服务器读文件
2. 备服务器定时轮询主服务器是否有新数据 如果有 则同步



指针查询：IP -> hostname（也会用于服务器收到IP数据报时 进行的主机名检查 因为有的访问控制可能只设置了主机名）

当某个组织获取域名空间的授权的时候 同时也获取了`in-addr.arpa`域名空间的授权

即添加正向映射的同时 也添加了一个反向映射

noao.edu -> 140.252.13.33

33.13.252.140.in-addr-arpa -> noao.edu





使用的传输层协议：

以UDP为主

使用TCP的场景：

- 当返回数据因UDP长度限制被截断时
- 主备之间同步数据时





### TFTP：简单文件传送协议

> 使用场景：用于对无盘系统进行系统引导

特点：

- 使用UDP，所以需要自己解决分组丢失和分组重复的问题

- 使用停止等待协议：即等拿到对方关于上一个分组的块编号的ACK后 再发送下一个分组 

- 分组数据大小固定为512B 收到数据小于512B的分组说明数据传输完成

- TFTP处理请求和具体传输的端口 不是一个端口 为了提高并发度 支持更多请求
- 无需用户名和密码 安全性低

![image-20220510075735637](https://gitee.com/yang_siping/static/raw/master/image-20220510075735637.png)



### BOOTP：引导程序协议

> 使用场景：
>
> 之前无盘系统 在系统引导时 获取自身IP的方式：RARP 
>
> RARP的缺陷：
>
> - 使用链路层广播 不能跨网络 必须在每个物理网络都配备一个RARP服务器
> - 只能获取IP信息

BOOTP：

- 用于在系统引导时获取数据 包括：自身IP 子网掩码 引导服务器IP 网关IP 引导文件名（用于之后TFTP读请求）

- 请求和响应能够被路由转发







问题：BOOTP服务器发送应答时 如何发送到客户主机

发送使用UDP数据报 链路层需要MAC地址 如果走ARP的话 当前被引导的主机还不知道自己的IP（IP为BOOTP服务器在这个应答中分配） 所以无法回复

解决方法：

- BOOTP服务器手动在自己的ARP高速缓存中加一个项 客户主机IP -> 客户主机MAC
- 广播（通常不采用 因为希望广播越少越好）



### TCP：传输控制协议

特点：提供面向连接 可靠的字节流服务

面向连接：

- 传输数据前需建立连接
- 两个socket之间的连接 不像UDP一样可以支持多播和广播

可靠：

- 应用数据会被分割为合适的数据块（为了不被IP分片）
- 对每个报文段 启动一个定时器 超时未收到确认 则进行重传
- 收到数据后给发送端发送一个确认
- 有首部和数据部分的检验和
- 收到报文段后 因为IP报可能不是乱序到达的 所以会先重新排序 然后再交给应用层
- 因为IP报会重复 所以接收端会丢弃重复的数据
- 通过窗口大小 进行流量控制 控制发送方的发送速率 避免接收方缓冲区溢出

字节流：socket就是一个文件 发送方写文件 接收方读文件

- 接收方无需了解发送方每次发送了多少字节 从里面取畸形
- TCP对字节流的内容不作任何解释 解释由应用层负责



首部：

- 源端口号 目的端口号：

  用于寻找发送方和接收方的进程（分用）

  socket pair：source ip source port dest ip dest port 这个四元组用来唯一确定一个TCP连接

- 序号：

  报文段中的第一个字节号 是一个`unsigned int` 到达2^32-1后又从0开始计数

- 确认序号：

  确认方所期望的收到的下一个序号 

- 6个标志位

  - URG：紧急指针有效
  - ACK：确认序号有效
  - PSH：让接收方尽快交给应用层
  - RST：重建连接
  - SYN：发起连接
  - FIN：发端完成发送任务

- 窗口大小：16bit

  用于进行流量控制 告知发送方接收端最多可以接收的字节数

- 检验和：

  检验范围：首部 + 数据

- 紧急指针

  是一个正的偏移量 序号 + 偏移量 = 紧急数据的最后一个字节的序号

- 常见可选字段：

  MSS：maximum segment size

  最长报文大小 本端所能接收的最大长度的报文段（用于避免IP分片）
  
  MSS = 路径MTU - TCP首部 - IP首部（理想情况下）



### TCP连接的建立与终止

tcpdump输出

![image-20220512180238876](https://gitee.com/yang_siping/static/raw/master/image-20220512180238876.png)



时序图

![image-20220512180254192](https://gitee.com/yang_siping/static/raw/master/image-20220512180254192.png)



连接建立的超时：

出现场景：当服务端多次未响应(发起方自适应增加重发间隔 避免增加网络拥堵情况)

![image-20220512180608883](https://gitee.com/yang_siping/static/raw/master/image-20220512180608883.png)



TCP半关闭：主动发起关闭TCP连接的一方 不再发送数据 但仍可以接收数据

使用场景：

将数据发送到一个远程机器上进行排序

然后等待返回

从标准输入中写入数据到TCP连接后 发送方就可以发送FIN命令 这样接收端就知道发送方发送完了数据（因为TCP是面向字节流的 接收方不知道发送方的字节流什么时候传输完） 

![image-20220514103836400](https://gitee.com/yang_siping/static/raw/master/image-20220514103836400.png)



主动关闭方的TIME_WAIT状态的作用：等待2MSL 两个报文最长生存时间（MSL默认为30s 或60s）

- 保证被动关闭方可以正常关闭：
- 保证本次连接的报文段都消失 不会影响到这个socket pair上建立的下一个连接



复位报文段：相当于检测到连接中的异常 主动断开连接 RST

出现场景：

- 目的主机的目的端口没有在监听(UDP的话 是发送ICMP端口不可达报文)
- 异常终止 主动释放连接
- 服务器重启后 之前的会话信息失效（可以用保活机制检测另一端是否消失）



当多个连接请求同时到达服务器时：

处于LISTEN状态的一段 有一个连接队列 存放处于ESTABLISHED状态（已经完成3次握手的）的但是还未被应用层接受的连接

队列是否已满会影响TCP服务器是否对SYN请求作出回应



### TCP的交互数据流

TCP报文段的两种类型：不同的类型采用不同的算法

- 成块数据：用户数据是满的
- 交互数据：用户数据往往小于10B 



交互式输入：一个数据分组里面只包含一个字节的按键（或一行命令的字节）

![image-20220517080418776](https://gitee.com/yang_siping/static/raw/master/image-20220517080418776.png)

经手时延的ACK（数据捎带ACK）：TCP接收到数据并不会立即发送ACK，而是会延迟等待一段时间（1-200ms 内核是200ms检查一次），以便将ACK与沿该方向需要发送的数据一起发送，以减少网络通信量



Nagle算法：

解决的问题：

交互式数据中的IP分组大小往往只有41B（20B + 20B + 1B)，这些小分组在广域网环境下会增加拥塞的可能

内容：

一个TCP连接上最多只能有一个未被确认的小分组，在分组确认到达前不能发送其他的小分组，这样就可以在等待发送的时间内累积小分组，确认到达时合并为一个分组发送出去（批处理的思想）

优点：自适应

- 局域网：确认速度快 数据发送速度快
- 广域网：确认速度慢 数据发送速度慢 但分组数量减少

缺点：

会增加数据发送的时延（可以使用TCP_NODELAY选项关闭Nagle算法）





### TCP的成块数据流

流量控制方式：

- 停止等待协议：

  TFTP使用 上面的Nagle算法也是类似的 即一个连接中最多只能有一个已发送但未确认的报文

- 滑动窗口协议

  允许发送方在停止并等待前可以连续发送多个分组（当前窗口大小决定最多可以连续发送的数量）

  并且接收方不必确认每一个收到的分组 累积ACK



![image-20220519181042640](https://gitee.com/yang_siping/static/raw/master/image-20220519181042640.png)

滑动窗口的扩缩容触发：

- 窗口左边沿右移：

  - 数据被发送：可用的窗口左边沿右移

  - 发送的数据被确认：提供的窗口左边沿右移

- 窗口右边沿右移：

  接收端的接收进程已经读取并释放了TCP缓存中的数据时

- 窗口右边沿左移：建议不使用



紧急方式：

- 目的：告知接收方数据流中有紧急数据 由接收方决定如何处理
- 使用：
  - URG = 1
  - 紧急指针指向紧急数据最后一个字节的序号



### TCP的超时与重传

可靠的保证：

要求接收方对收到的数据进行确认，但是确认本身和数据一样，也可能在网络中丢失，所以需要对发送的数据设置一个定时器，当定时器时间到了 还没收到确认，就进行重传



TCP连接中的定时器：可以理解为Java中的定时任务

- 重传定时器：用于希望收到另一方的确认
- 坚持定时器：保持窗口大小信息能同步到对方
- 保活定时器：检测连接对端的崩溃与重启
- 2MSL定时器：测量一个连接处于TIME_WAIT状态的时间



拥塞窗口与接收窗口：实际发送取两者的最小值

- 一个是发送方根据报文的接收情况（超时或者重复ACK） 对网络拥堵情况的主动感知

  从而限制自身的发送速率

- 一个是接收方根据缓存中剩余的空间 告知发送方还允许发送的数量

  从而限制发送方的发送速率



慢启动与拥塞避免：

都需要维护两个变量：

- 拥塞窗口：cwnd
- 慢启动门限：ssthresh

1. 连接刚开始 用慢启动 cwnd增长规则：一个ACK cwnd +=1 (一个MSS)

   慢启动是指数型增长

2. cwnd到达ssthresh之后 一个ACK cwnd += 1/cwnd

   即一个RTT内 cwnd最多 +1

   拥塞避免是线性增长

3. 发生超时时 说明网络拥塞 需要立即减少发送方发送报文的数量

   ssthresh = cwnd / 2

   cwnd = 1

   然后执行慢启动



快速重传与快速恢复：

主要解决的问题：

还有ACK能过来 说明网络不是特别拥堵 （接收方能收到数据 并且ACK能回到发送方）

不需要用慢启动来突然减少数据流 

快速重传的触发：

3个重复的ACK 3个是因为 有可能是1-2个失序的报文段到达 

3个就很有可能是报文段丢失了 直接重传需要的报文段 不用等到超时

快速恢复的过程

1. cwnd = cwnd / 2

   ssthresh = cwnd

   cwnd += 3（意思是有3个数据包被收到了 尽管不是有序的）

2. 重传丢失的数据包

3. 如果收到重复数据报文段的确认 cwnd + 1

4. 如果收到新数据报文段的确认 说明重复数据都已经接收了

   cwnd = ssthresh 再次进入拥塞避免



一个TCP连接关闭时 生成的辅助数据会被记录下来（达到一定传输数据量的）

以便后续复用（自适应）

内容：

- RTT和均值偏差：用来计算重传时间的
- ssthresh：控制慢启动转换成拥塞避免的数据量



超时重传时TCP允许重新分组 以发送一个更大的报文段

将需要重传的数据和待发送的数据合在一起 来提高传输性能

因为接收方的确认是基于字节序号 而不是报文段序号（面向字节流）



### TCP的坚持定时器

> 主要是为了让接收方接收窗口的信息能同步给发送方
>
> 处理打开窗口的ACK丢失时 双方互相等待的情况
>
> 所以需要发放方周期性地进行窗口探测 直到连接终止或者窗口打开



糊涂窗口综合征：

接收方告知一个小的窗口时 发送方也会发送少量的数据 

而不是等待其他数据 以发送一个更大的窗口（这样就降低了网络传输的效率）

主要是为了避免发送小报文



处理方法：

- 接收方：只在以下情况才会打开窗口

  - 新窗口比当前窗口增加一个MSS 

  - 窗口增加了总窗口的一半

    （应用程序在从TCP接收缓存中读取数据时 会检查是否需要更新窗口信息给发送方）

- 发送方：只在以下情况才发送数据
  - 可以发送一个满长度的报文段
  - 达到接收方窗口一半大小
  - 没有未被确认的数据



### TCP的未来与性能



分组大小：

不是越大越好，因为中间设备路由器是存储转发设备，具有一定的并行处理能力



长肥管道的问题：

> 长肥管道：带宽时延乘积很大
>
> 有可能是距离很长
>
> 或者宽带很大

- TCP窗口大小为16bit 所以原始大小最大为65535字节 需要一个更大的窗口来提高分组大小
- 需要更好的RTT测量机制
- 序号再次从0循环的速度加快 需要一种机制来保证上一个连接的分组不会被接收



解决方法：

- 窗口扩大选项
- 时间戳选项
- PAWS：给每个分组编序号



### SNMP：简单网络管理协议

> 目的：对网络中的设备进行管理
>
> 设备：



基于TCP/IP的网络管理：

- 管理进程

- 网络单元：被管理的设备 运行TCP/IP协议的路由器 终端服务器等

- 代理进程：网络单元上与管理相关的软件
- 管理进程与代理进程之间的通信协议：SNMP

- MIB：管理信息库，包含代理进程中所有可被查询和修改的参数
- SMI：管理信息结构，定义MIB中的数据类型

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

![image-20220602071737486](/Users/yangsiping/Library/Application Support/typora-user-images/image-20220602071737486.png)



对象标识符：管理信息库中的变量名 层级结构 

![image-20220602072032260](/Users/yangsiping/Library/Application Support/typora-user-images/image-20220602072032260.png)





### Telnet和Rlogin：远程登录

使用场景：远程登录到一台网络主机上

两种远程登录应用：

- Telnet：不同的操作系统之间
- Rlogin：主要是Unix



![image-20220603070623280](/Users/yangsiping/Library/Application Support/typora-user-images/image-20220603070623280.png)

> 因为只有一条TCP连接 所以需要一些方法来表述传输的是命令还是数据



**Rlogin**

命令的传输：

- s -> c : 

  利用TCP紧急指针来告知命令所在位置 将命令放到紧急数据的最后一个字节

  适合于传输量比较大的场景 接收方只需要留意紧急指针指向的字节

- c -> s：

  用特殊字符表示命令 适合于传输量比较小的场景 因为接收的一方需要检查是否收到连续的两个0xff字节



客户主断中断数据传输时发生的事情：

> 主要设计目的：
>
> - 避免客户端停止了之后 还继续收到服务端发送过来的数据
> - 被拒绝接收的数据及时清理 以释放接收方缓存空间

1. ctrl+c 停止终端输出
2. 终端缓存被填满 rlogin客户进程无法继续写入 
3. 客户进行无法继续从TCP接收缓存中拿去数据 所以TCP接收缓存填满
4. 客户端TCP 通告服务端TCP接收窗口为0
5. 服务端停止发送 TCP发送缓存满
6. rlogin服务进程无法写入 导致无法继续从应用程序读取数据 应用程序的输出缓存满
7. 中断键命令到达服务器 应用程序接收到后清空自己的缓存 并唤醒rlogin服务器进行 通过紧急指针给客户进程发送清仓输出命令 告知客户丢弃所有从服务器收到的数据



**Telnet**

- 定义了NVT 网络虚拟终端，实际c-s的交互是通过NVT，操作系统的数据要先转化为NVT的数据格式

- 命令传输方式为带内信令，`0xff`后的一个字节为命令字节 要传输0xff 则传输连续两个0xff 
- 发送数据前首先需要进行选项协商数据



数据传输方式：

- 半双工 
- 一次一个字符
- 准行方式
- 行方式



同步信号：

以TCP紧急方式发送，因为就是TCP数据流已经被TCP流量控制（对端接收窗口为0） TCP紧急方式也能发送（因为它不包含数据）



### FTP：文件传送协议

目的：用于不同主机间的文件传输

处理不同系统之间差异的方式：只支持有限数量的文件类型（ASCII 二进制）和文件结构（面向字节流）



协议：使用两个TCP连接，带外信令

- 控制连接由客户端主动打开，用于传输命令，需要减少时延
- 数据连接在文件传输时打开，用于传输数据，需要提高吞吐量

![image-20220606071248988](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202206060712113.png)



数据的可选表示：unix下，基本上就是面向字节流

- 类型： ASCII / 二进制文件
- 格式：只允许非打印
- 结构：只允许文件结构
- 传输方式：只允许流方式



连接管理：

数据连接的作用：

- c -> s 传输文件

- s -> c 传输文件或目录

  用数据连接传输目录的好处在于可以让客户以文件形式保存目录，而不是把目录显示在终端，同时也避开了控制连接传输时的行大小限制



控制连接一直是全程打开的，数据连接是数据传输时打开的

数据连接的建立过程：（主动模式）

1. 客户端选择一个临时端口号，并用PORT命令从控制连接（服务端端口21）上把端口号发送给服务器
2. 服务器接收到端口号后，从端口20主动发起TCP连接到客户端给的临时端口



主动模式与被动模式：

- 主动模式：服务端主动发起TCP连接客户端的打开的数据端口
- 被动模式：客户端主动发起TCP连接服务端打开的数据端口（默认为20） 这样可以主动设置防火墙 放行该端口的TCP数据



### SMTP：简单邮件传送协议

![image-20220608072552025](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202206080725154.png)

传输过程：

1. HELO 客户主机名
2. MAIL 邮件发送人
3. RCPT 邮件接受人
4. DATA 发送数据
5. QUIT 结束邮件交换



组成：

- 信封：MAIL 和 RCPT指明
- 首部：供用户代理使用
- 正文



中继代理：

出现原因：

- 可以简化终端MTA(Message Transfer Agent）报文传送代理的配置，只需配置好中继MTA即可
- 一个机构的多个系统使用一个中继MTA，对外可以表现为一个

![image-20220608073655332](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202206080736452.png)



### 网络文件系统

RPC：网络程序设计方法

- 客户端调用远程过程的时候 只是调用了客户端stub（一个位于本机上 由RPC程序包生成的函数）

  stub会将传参封装成网络报文 发送给服务端

- 服务端的stub收到网络报文后 从其中解析出传参 调用本机上的函数

- 将函数返回值返回到服务端stub stub将其封装为网络报文 并将报文发送给客户端stub

- 客户端stub从接收到的网络报文中取出返回值 返回给调用者



RPC好处：

- 向程序员屏蔽了网络编程的细节
- 简化了客户端与服务端环境异构导致的编码问题



XDR（外部数据表示）：
定义了RPC请求报文和响应报文中值的编码，如字节序问题，用于解决异构环境之间交互的问题



NFS：

目的：客户可以透明地访问服务器上的文件，不产生副本，而是只访问进程引用文件的一部分

实现：在操作系统内核中 执行RPC

特点：无状态，设计目的是为了简化服务器的崩溃恢复操作（不保存客户状态 所以只需要初始化好自己就行）

![image-20220613071842205](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202206130718360.png)

文件句柄：对远端服务器上文件的一个引用

安装协议：客户端在访问服务器上的文件时，需要先安装对方的文件系统，最后可以获得服务器文件系统的一个文件句柄（即要mount的服务器文件系统的根目录）



UDP更适合局域网，TCP更适合广域网，因为广域网中拥塞和丢包经常发生，TCP可以拥塞避免和重传





