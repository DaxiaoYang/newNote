# Unix环境高级编程

[TOC]

## Unix基础知识

![image-20220801072024911](/Users/yangsiping/Library/Application Support/typora-user-images/image-20220801072024911.png)

应用程序 -> 系统调用/公用函数库 -> 内核 -> 硬件资源

> 库函数是对系统调用进行的进一步的封装
>
> 对于应用程序(调用方)而言 他们都是C函数 没有区别



**进程控制**：

- fork

  用于生成子进程，在父进程中返回子进程ID 在子进程中返回0

- exec

  用指定的程序文件替换了子进程原先的执行文件

- waitpid

  等待子进程终止



**信号**：

- 作用：用于通知进程发生了某种情况 可以用于进程之间交互

  如ctrl + c  kill函数

- 处理方式：

  - 忽略
  - 按系统默认方式
  - 自定义函数处理



**进程时间**：CPU时间 = 用户CPU + 系统CPU 用来衡量进程使用的CPU资源

- 用户CPU时间：进程执行用户指令消耗的时间
- 系统CPU时间：该进程执行内核程序消耗的时间
- 时钟时间：进程从开始运行到现在的经过的时间，包括等待IO阻塞等时间



## 文件IO

文件描述符：用于标识文件，是一个非负整数，在进程打开或创建文件时，由内核返回给进程



打开文件时可以指定的参数：

- O_NONBLOCK：

  当打开的文件是一个FIFO 块特殊文件 字符特殊文件时，后续文件IO操作设置为非阻塞方式（读不到数据 直接返回）

- O_SYNC：

  写文件时 等待物理IO完成和文件属性更新后返回

  

关闭文件：进程终止时，内核自动关闭所有的打开文件



文件偏移量：

从文件开始出计算的字节数，读写操作都从当前文件偏移量处开始，当写的文件偏移量大于文件长度时，会造成文件空洞，空洞不占用磁盘块



文件IO效率：

当读写使用的bufferSize大小与磁盘块大小一致时，效率最高



进程间共享文件：

内核中表示文件的数据结构：

- 每个进程在自己的进程表中有一个记录项，记录项包含一张打开文件描述符表

  表项内容：

  - 标志 非负整数 fd
  - 内核文件表表项指针

- 内核为所有打开文件维持一张文件表

  - 文件状态标志：同步、非阻塞等
  - 当前文件偏移量
  - 文件v节点表项指针

![image-20220802080920878](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208020809900.png)

v节点：与文件系统无关，用于统一对不同文件系统类型的文件的操作

i节点：与文件系统相关



![image-20220802081224729](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208020812751.png)

当两个进程打开同一个文件时，在内核的打开文件表中会产生两个文件表项，因为他们各自需要持有不同的文件偏移量（文件描述符也不一样，但是也会有多个文件描述符指向同一个文件表项的情况 如fork后父进程和子进程共享文件表项）



文件相关的原子操作：应对多进程同时处理同一个文件的情况

- 追加写，之前：lseek先定位到文件末尾，再写，不是原子操作，现在可以在打开文件时设置O_APPEND标志，每次写都先定位到文件尾端（两个操作合成了一个原子操作）
- pread pwriter：原子性执行定位和IO操作
- 检查文件是否存在和创建文件是一个原子操作



内核写文件步骤：(一般是延迟写)

1. 将数据从用户区复制到内核缓冲区
2. 排入写队列
3. 写入磁盘

延迟写带来的问题：文件系统的内容与内核缓冲区不一致

保证一致性手段：

- sync：update系统守护进程 每个30s 刷一下盘 将有修改的块放入写队列

- fsync：等待写盘操作结束才返回 并且更新文件的属性 常用于数据库（等效于fcntl设置文件描述符fd的同步写标志O_SYNC）

  ![image-20220803080026226](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208030800255.png)

- fdatasync：也是等待写盘操作结束才返回 只影响文件的数据部分



## 文件和目录

文件类型：

- 普通文件：文本/二进制
- 目录文件
- 块特殊文件：提供对设备带缓冲的访问
- 字符特殊文件：提供对设备不带缓冲的访问
- FIFO：管道，用于进程间通信
- Socket：用于进程间的网络通信
- 符号连接：指向另一个文件



文件系统：

每个分区都可以包含一个文件系统，i节点时固定长度的记录项

![image-20220810065711513](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208100657616.png)

![image-20220810071258022](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208100712050.png)

文件链接：

- 硬链接：

  目录块中的目录项指向i节点的链接 硬链接数为0时 才可删除文件

  限制：

  要求链接和文件在同一文件系统中

  只有root用户才能创建指向目录的硬链接

- 符号链接：

  文件内容就是指向的文件的名字，是一个文件的间接指针

  避开了硬链接的限制

  

## 标准IO库

> 主要目的是对每个IO流进行自动的缓冲管理

实际IO：文件描述符 fd - 文件

标准IO：流 FILE对象 - 文件

FILE对象：

- 用于实际IO的文件描述符
- 缓冲区的指针 长度 当前缓冲字符数
- 出错标志



缓冲：

目的：减少read write系统调用的次数

类型：

- 全缓冲：普通文件

  只有当缓冲区内容全部填满时(或者flush) 才将数据写到磁盘

  当一个流第一次执行IO操作时 IO库会使用malloc申请缓冲区

- 行缓冲：指向终端设备的流：标准输入 标准输出

  输入和输出遇到换行符时 执行实际IO

  注意点：

  - 当行缓冲满了 就算没有遇到换行符 也会执行IO操作
  - 从带行缓冲的流中获取输入数据 会flush所有的行缓冲输出流 

- 不带缓冲：标准错误

  希望字符能尽管输出



## 进程环境

**main函数的执行**:

1. 可执行文件将启动例程作为程序的起始地址（连接编辑器中设置）
2. 启动例程从内核中获取命令行参数和环境变量值 传入main函数





**进程终止的方式**：

正常：

- 从main函数返回

  `exit(main())` 实际上是从main返回后立即调用exit 入参为进程终止状态 非0为异常

- 调用exit

  先调用终止处理函数，在关闭所有打开流

- 调用_exit / _Exit

  不执行终止处理函数 不关闭打开流

- 最后一个线程从其启动例程返回

- 从最后一个线程调用pthread_exit

异常：

- 调用abort
- 接到一个信号
- 最后一个线程对取消请求做出响应



终止处理函数：atexit

![image-20220830080450701](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208300804726.png)





**C程序的存储空间布局**

- 正文段：

  机器指令部分 在内存中只有一个份副本 可共享 只读

- 初始化数据段：

  存储程序中明确需赋初值的变量

  `int count = 99; // 函数外声明`

- 未初始化数据段

  程序执行前，内核将该段中的数据初始化为0

  `long sum[1000] // 函数外声明`

- 栈

  存储局部变量以及函数调用所需保存的信息 

- 堆

  动态存储分配

![image-20220830081943361](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202208300819394.png)



**共享库**

目的：类似于享元模式 复用公用的库函数 使得内存中只有一份库函数的副本

执行：第一次调用库函数时，动态链接将程序和共享库函数链接增加了运行时开销，减少了可执行文件的大小（时间换空间），而且升级库函数 无需对调用库函数的文件进行重新链接（解耦）



**存储空间分配**

- malloc
- calloc：分配的内存中的每一个Bit都初始化为0
- realloc：增加或者减少分配去的长度



**setjmp longjmp**

目的：实现跨函数之前的跳转，跳多个栈帧

问题：编译优化后 局部变量的值会丢失



**进程的资源限制**

会由子进程继承

- getrlimit
- setrlimit



## 进程控制

**进程标识**

用一个非负整数来表示唯一的进程ID，唯一但是可以被复用

特殊：

- pid = 0:内核中的交换进程 负责进程调度
- pid = 1：init进程 读取与系统初始化相关的文件 不会终止 是所有孤儿进程的父进程 在其子进程终止时会调用wait函数获取其终止状态 释放资源



**fork**

```C
pid_t fork()
```

fork后会有两次返回，一次在父进程，一次在子进程，子进程中返回0,父进程中返回子进程的pid

子进程拥有父进程数据段、堆、栈的副本，但是具体实现会有优化，写 时复制COW,但这些是只读的时候，由父进程和子进程共享，当父进程或子进程尝试修改该区域时，内核为修改的那部分区域创建一个副本

fork下的文件共享：子进程和父进程共享文件表项

场景：

- 父进程等待子进程完成 无需对文件描述符做任务处理 文件偏移量已经自动更新
- 父进程和子进程各自执行不同的程序段 会各自关闭不需要使用的文件描述符 减少对对方的干扰(web服务器常用)

场景例子：子进程写标准输出 返回后 父进程写标准输出 由于共享文件表项 文件偏移量也共享 所以其写的东西追加在子进程写的东西之后



![image-20220905084255193](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202209050842246.png)

fork的使用场景：

- 父进程希望子进程在复制自己的同时，执行不同的代码段，如网络服务进程中，父进程继续等待请求，子进程处理具体的请求
- 一个进程要执行不同程序，shell中常见，fork后接exec



**exit**

入参是退出状态，异常终止下内核将产生异常终止的终止状态，这些状态父进程调用wait/waitpid都可以获取

如果父进程先于子进程终止，子进程的父进程就会变成Init进程（pid = 1）（实现：进程终止时，内核会遍历所有的进程 判断是否有该进程的子进程）

如果子进程先于父进程终止，终止状态等信息会存在内核中，父进程调用wait/waitpid的作用：

- 获取终止状态
- 让内核释放进程使用的内存空间 关闭打开的文件

> 僵尸进程：子进程终止后 父进程并未wait等待取得子进程的终止状态 导致该进程占用的内存资源未释放 文件也一直打开
>
> 当进程fork出一个子进程但是不想等待子进程终止 也不想让子进程成为僵尸进程 可以使用两次fork的技巧：
>
> 两次fork，fork出子进程后子进程 再fork一个出一个子进程，此时第一个子进程终止自己，使得第二个子进程成为孤儿进程，父进程挂给init进程，由init进程负责
>
> 



**wait/waitpid**

调用时：

- 如果该进程的所有子进程都在运行 则阻塞
- 只有有一个子进程终止了 就会获取其终止状态 并返回
- 如果没有子进程 则出错

```c
pid_t wait(int* statloc);
pid_t wait(pid_t pid, int* statloc, int options);
```



**竞争条件**

定义：有多个进程都尝试对某个共享资源进行处理，处理结果依赖于进程运行的顺序

例子：如父进程和子进程共享标准输出，fork后打印顺序有可能会乱

解决方法：同步等待从子进程/父进程传递过来的信号 `TELL & WAIT`



**exec**

做的事情：从磁盘中加载新程序替换当前进程的正文、数据、堆、栈段



**解释器文件**

shell文件 exec实际执行的不是shell文件 而是/bin/bash

```shell
#!/bin/bash   #解释器
```



**进程调度**

可以调整进程的nice值来影响进程获取CPU的优先级

权限：

- 进程自身可以降低自己的优先级 但是不能提高
- 特权进程可以提高进程的优先级



## 进程关系

**终端登录**

![image-20220915080248254](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202209150802485.png)



**网络登录**

![image-20220915081551404](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202209150815457.png)



**进程组**

进程组的ID=组长进程的ID

只有进程组中还有一个进程存在 进程组就存在



**会话**

进程组的集合

![image-20221009070637757](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202210090706870.png)

进程组的构成：shell的管道

```shell
proc1 | proc2 & # 后台
proc3 | proc4 | proc5 # 前台
```

利用fork替换一个进程的进程ID:

fork后 等待父进程终止 子进程继续 此时进程组ID不变 进程ID是新分配的



**控制终端**

一个会话可以有一个控制终端 负责传递输入和信号到前台进程组

登录shell时会自动建立控制终端



**作业控制**

允许一个终端上启动多个作业（进程组） 能跟终端直接交互的只有前端进程组



**shell执行程序**

![image-20221009074406525](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202210090744560.png)



**孤儿进程组**

系统会向孤儿进程组中处于停止状态的每个进程发送挂断信号和继续信号，父进程（前台作业）终止时 子进程变成后台进程组



## 信号

信号是软件中断，提供了进程处理异步事件的方式，实现上就是为信号码注册一个回调函数



**产生信号的条件**：

- 在终端上按ctrl+c 通常产生中断信号
- 硬件监测到异常后会产生信号：除0 无效内存引用
- 进程调用kill(2) / kill(1)可以将信号传递给其他进程（前提是所有者相同 或者是超级用户）
- 监测到软件条件发生：网络连接传来数据、进程设置的定时器超时



**信号的处理方式**：

- 忽略
- 捕捉信号：需要在程序中注册一个回调函数
- 执行系统默认动作：大多数都是终止进程 + 生成core文件（进程的内存映像）



**signal函数**：

注册回调函数

```C
typedef void Sigfunc(int);
// 入参：信号值 一个入参为int出参为void的函数函数指针
// 返回值：该信号值之前绑定的函数指针
Sigfunc* signal(int, Sigfunc*);
```



exec和fork对信号捕捉函数设置的影响：

- 将要捕捉的信号还原为默认 因为执行的程序变了
- fork后的子进程继承父进程捕捉的信号，因为子进程和父进程共用代码区 所以信号捕捉函数的地址在子进程中是有意义的



**不可靠的信号**

早期版本的问题：

- 信号会丢失，信号传不到指定的进程（不可靠）
- 不具备延迟处理信号的能力
- 接到信号进行处理后 会重置改信号的处理为默认 导致有个时间窗口下执行的还是默认的处理



**中断的系统调用**

进错在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用被中断不再执行

> 低速系统调用 可能会使进程永远阻塞的系统调用 如读管道 网络设备的数据不存在



## 线程

线程出现的目的：进程在某一时刻可以同时做多件各自独立的任务

好处：

- 为每种事件类型分配单独的处理线程 在处理事件时可以采用同步方式（不涉及其他事件的资源时）
- 自动实现进程内内存和文件描述符的共享
- 分解问题给不同的线程 提高吞吐量
- 交互程序中：将处理用户输出的部分交给单独的线程 改善响应时间

> 单核 但是有IO密集型的任务时 多线程也可以提高运行效率

线程中包含的内容：执行环境上下文信息

- 线程ID
- 寄存器值
- 栈
- 调度优先级
- 信号屏蔽字
- errno变量
- 线程私有数据



**线程同步**：



读写锁使用场景：读多写少



条件变量：线程同步的一种机制 

需要先获取锁 在某个条件变量上等待时 将线程放到等待条件的线程列表上 然后解锁



自旋锁：

使用场景：等待锁的时间短 不希望在线程调度上花费过多时间



屏障：

允许任意数量的线程等待 直到所有线程都运行到同一个点



## 线程控制

**线程属性**：

- detachstate

  不接收线程的终止状态 让操作系统回收线程占用的资源

- guardsize

  栈内存警戒区大小 如果达到了这里 应用程序会受到出错信息 默认为系统页大小 4K

- stackaddr

  线程栈的结尾位置，当线程栈的虚地址空间用完了 考研用malloc 或者mmap分配其他空间 然后重新set stackaddr的值

- stacksize

  线程默认栈大小



**同步属性**（线程的同步对象的属性）

- 互斥量属性

  - 进程共享

    不同的进程可以各自独立的地址空间可以映射到同一个物理内存块 

  - 健壮

    当多个进程访问一个互斥量时 当持有互斥量的进程终止时 需要解决锁无法被释放的问题 需要恢复应用状态 如果无法恢复则将该互斥量置为永久不可用状态

  - 类型

    - normal：不做任何错误检查或者死锁检测
    - errorcheck：提供错误检查
    - recursive：可重入锁
    - default：Linux映射为normal

- 读写锁属性

  - 进程共享

- 条件变量属性：

  - 进程共享
  - 时钟：控制超时参数中采用的是哪个时钟

- 屏障属性：

  - 进程共享属性



**线程私有数据**

目的：每个线程访问自己的数据副本 不需要担心与其他线程的同步访问问题



**取消选项**：影响线程响应cancel函数时的行为

- 可取消状态

  enble时 线程到达取消点时 会对取消请求进行处理

  disable时 取消请求会被挂起

- 可取消类型

  - 延迟取消： 即到达取消点后才取消（默认）
  - 异步取消：线程可以在任意时间取消



**线程和信号**

- 信号的处理是所有线程共享的，一个线程修改了某个信号相关的处理行为后，所有其他的线程都必须共享这个处理行为的改变
- 进程中的信号是发送到线程上去的

信号收发方式：

- 线程接收信号：sigwait(同步等待信号)
- 线程发送信号：pthread_kill





## 守护进程

定义：系统引导装入时启动 系统关闭时终止 在后台运行的进程



**守护进程的特征**

- root特权运行
- 没有控制终端

























