# Kafka

[TOC]

## 入门

### 消息引擎系统ABC



**定义**

> 一款开源的消息引擎系统 Messaging System



消息引擎系统：

> **定义**：
>
> 维基百科：是一组规范，企业利用这组规范在不同系统间传递语义准确的消息，实现松耦合的异步式数据传递
>
> 民间：系统A发送消息给消息引擎系统，系统B从消息引擎系统中读取A发送的消息
>
> 两个关键点：
>
> - 消息引擎传输的对象是**消息**
> - **如何传输消息**属于消息引擎设计的一部分
>
> 需要解决的问题：
>
> - 消息编码格式的设计
>
>   kafka: 结构化的二进制的字节序列
>
> - 设定具体的传输协议：用什么办法把消息传输出去
>
>   点对点：一个消息由一个生产者发出，只能给一个消费者消费
>
>   发布/订阅：有topic的概念，topic是逻辑语义相近的消息容器
>
>   一个topic的生产者和消费者都可以有多个



为什么需要消息引擎系统，而不是直接向对方系统发送信息：

- **削峰填谷**
- 解耦发送方与接收方



两个进程之间进行数据交互的方式：

- 通过数据库/磁盘文件：进程A写库，进程B读库
- 通过服务调用：REST RPC
- 通过消息传递：经由消息引擎系统





### Kafka术语



**主题**：*topic*. 是生产者发布和消费者订阅的对象

**生产者**：向主题发布消息的客户端应用程序，可以向一个或者多个主题发布消息

**消费者**：订阅主题消息的客户端应用程序，可以同时订阅多个主题的消息

**客户端**：生产者和消费者

**服务器端**：由被称为Broker的服务进程构造，一个Kafka集群由多个Broker构成，通常部署在不同机器上，

> Broker的作用：
>
> - 接收和处理客户端发送的请求
> - 对消息进行持久化



**实现高可用的手段**：

- 实例集群，将Broker部署在不同的机器上，一台挂掉了，也可以由其他的Broker提供对外服务
- 备份机制 *replication*：将相同的数据拷贝（副本 *Replica*）到多台机器上



**副本**：

类型：

- 领导者副本：跟客户端交互
- 跟随者副本：跟随领导者副本，不与客户端交互

工作机制：

生产者向领导者副本写消息，消费者从领导者副本读消息

追随者副本：向领导者副本发送请求，将领导者最新生产的消息发给它，保持数据同步



**分区 *partitioning***：将数据分割成多份保存在不同的Broker中（通过不同分区的领导者副本分布在多个Broker中）

将每个主题划分成多个分区，每个分区都是一个组有序的消息日志，生产者发布的每条消息只会发送到该主题的一个分区中



**分区与副本的关系**

副本是分区这个层级下的概念，一个分区下可以有多个副本（一个副本在一个broker中），由一个领导者副本和多个跟随者副本构成



**分区位移**

每条消息在分区中的位置信息



**消息架构**

- 主题层：一个主题可以配置M个分区，一个分区可以配置N个副本（根据Broker数量）
- 分区层：每个分区的N个副本中只能有一个充当领导者角色，与客户端交互，其他副本提供数据冗余
- 消息层：一个分区中包含多条消息，消息的位移从0开始递增



**Broker持久化数据的方式**

使用消息日志 *Log*，来保存消息数据，一个日志就是物理磁盘上一个只能追加写的文件，采用的IO操作为性能较好的顺序IO写操作

日志中由多个日志段组成，后台会有定时任务定期地检查老的日志段是否能够被删除



**消费者组**：实现了P2P的消息模型

由多个消费者实例组成，来共同消费一组主题，主题中不同分区的领导者副本被不同的消费者消费



**重平衡 *Rebalance***

当消费者组中某个实例挂掉了，Kafka会检测到，并将这个实例之前负责的分区转移给其他活着的消费者



**消费者位移**：消费者在消息消费的过程中需要有一个字段记录消费到了分区的哪个位置（消费进度的指示器）



![](https://static001.geekbang.org/resource/image/58/91/58c35d3ab0921bf0476e3ba14069d291.jpg)

问题：为什么Kafka中的追随者副本不像Mysql一样对外提供服务（从读）

- 数据从Leader副本同步到Follower副本需要时间
- 从读是为了减轻主节点的压力，但是如果各个分区的Leader副本均匀分散在不同的Broker上，也可以达到负载均衡的效果



> Kafka是消息引擎系统，也是分布式流处理平台
>
> 设计之初的三个目的
>
> - 提供一套API实现生产者和消费者
> - 降低网络传输和磁盘存储开销
> - 实现高伸缩架构





### kafka版本号

版本号组成：大 + 小 + patch

**版本更迭**

- 0.7：只提供了最基础的消息队列功能 无副本

- 0.8 ：引入了副本机制 成为一个完备的分布式高可靠消息队列解决方案

  建议使用0.8.2.2版本 不建议使用0.8.2.0之后的producer API

- 0.9： 增加了基础的安全认证/权限功能 用Java重写了消费者API 引入了Kafka Connect组件

  不建议使用consumer API

- 0.10：引入了Kafka Streams 正式升级成为分布式流处理平台

  建议版本0.10.2.2 建议使用新版consumer API

- 0.11 producer API幂等 事务API 消息格式重构 建议版本0.11.0.3 

- 1.0 2.0：Kafka Streams的改进 建议版本2.0

**经验**

- 注意消息格式的变化
- 客户端的版本保持与服务端的一致（为了优化）
- 不要成为最新版本的小白鼠





## 基本使用



### Kafka线上集群部署方案



**部署需要考虑的因素**

- 操作系统
- 磁盘
- 带宽



**操作系统**

Linux的优势：

- IO模型的使用

- 数据网络传输效率

  Zero Copy 避免数据拷贝

- Kafka社区支持度



IO模型：越后面的性能越好

- 阻塞式IO：Java Socket对象阻塞模式
- 非阻塞式IO：Java Socket对象非阻塞模式
- IO多路复用：Linux select
- 信号驱动IO: epoll
- 异步IO

Kafka客户端：Java selector 在Linux上的实现是epoll 在Windows上的实现是select



**磁盘**

追求性价比，使用机械磁盘即可



**磁盘容量**

需要考虑的因素：

- 新增消息数
- 消息留存时间
- 平均消息大小
- 备份数
- 是否启用压缩 压缩比



**带宽**

千兆网： 1Gbps

假设单台服务Kafka使用的带宽是240Mb 最多使用70%的带宽

如果一个小时要处理1TB=8Tb=8000Gb=8000000Mb的数据

那每秒需要处理2222Mb的数据

所以需要10台服务器（服务器上只跑Kafka 其他的不跑）

如果消息还需要额外复制一份 -> 20台





### 集群参数配置



**Broker端参数配置**

- 存储消息相关：不同的目录最好挂载不同的磁盘中 提高IO效率 实现故障转移
- Zookeeper相关：zookeeper中存储了kafka的所有元信息：broker topic 分区 Leader副本
- broker连接相关：用什么协议与Broker进行通信
- Topic相关 ：是否允许自动创建Topic Leader选举相关
- 消息的留存：留存时间 留存空间 单个消息最大容量 



**Topic相关配置**

- 消息的留存时间和空间
- 消息的尺寸



**JVM相关配置**

- 堆大小
- GC



**操作系统相关配置**

- 文件描述符数量
- 文件系统
- swap
- 页缓存



## 客户端实践及原理剖析



### 生产者消费分区机制

**Kafka消息层级**

1. 主题：某类消息

2. 分区：读写单位 一个主题中的消息分布在多个分区中 消息在分区之间互不重叠

   ​			每个分区又可以配置多个副本 副本之间数据是需要同步的

   ​		    其中领导者副本负责实际的与外部的交互 

3. 消息：存储单位



**分区的作用**

- 负载均衡 多分区之后 让每个分区的领导者副本在不同的Broker中 
- 高伸缩性：可通过增加分区 增加节点的方式水平扩容 提高处理能力



**分区策略**：决定某个消息会被放到哪个分区中

- 默认策略：如果有Key 就对Key作哈希 然后取余

  ​					没有Key就是轮询

- 轮询策略：分布最均匀

- 随机策略

- 按Key做Hash：可保证同一个Key的消息放到同一个分区中 被顺序消费

- 自定义策略



### 生产者压缩算法

**压缩作用**：时间换空间 更高的CPU使用 换取更少的存储空间和网络带宽占用



**消息格式**

消息集合：消息项组成

压缩的对象是整个消息集合



**压缩**：

- 生产者端进行压缩

- broker端也会进行压缩：

  - 指定了broker端的压缩算法时 broker会先解压（如果producer压缩了）再压缩

  - 当消息格式不一致时（存储用的还是老的消息格式）broker先解压 转换消息格式 再压缩

    **会丧失Zero Copy的特性**



**解压**

- Broker解压
- Consumer解压



一般是producer压缩 broker存储 不做动作 consumer解压



**压缩算法**

算法需要考虑的因素：

- 压缩比：zstd最高
- 压缩速率: lz4最快



**最佳实践**

如果CPU资源不紧张 推荐使用zstd压缩算法 节省带宽资源和存储空间



### 无消息丢失配置

**Kafka的保证**

> 对已提交的消息 作有限度的持久化保证



**生产者导致的丢消息场景**

- 消息没能到达Broker （网络抖动）
- 消息大小/格式不符合Broker要求 导致Broker拒绝接收该消息



**消费者导致的丢消息的场景**

需要保证的顺序：

1. 先消费消息
2. 再提交消费位移



- 先提交位移 再消费数据 但是并没有消费完
- 单个Consumer多个线程消费 有的线程没有消费完 就提交位移了



**配置**

- Producer端

  发送时设置回调函数 处理发送失败的情况

  设置重传次数

  将已提交定义为所有的broker都接收到了之后

- Broker端

  

- Consumer端

  先消费 再提交





### 客户端中的拦截器功能



**生产端拦截器**

- 消息发送前
- 消息提交后



**消费端拦截器**

- 消费消息前
- 消费位移提交后



**应用场景**

计算消息的端到端的平均延时





### Java生产者管理TCP连接



**选用TCP协议的原因**

- 可以利用TCP多路复用特性
- TCP客户端支持的语言多



**TCP连接的建立**

- 生产者实例创建时 会开启一个sender线程 与配置中的所有的Broker建立TCP连接
- 当从Broker中获取的元数据时 会建立与所有的broker的连接
- 当发送消息 发现没有与该broker建立连接时 会建立与该Broker的连接



**TCP连接的断开**

- 生产者close 或者生产者进程挂掉
- broker断开  客户端感知不到（超过空闲时间）





### 幂等生产者与事务生产者



**消息精准交付的语义**

- 最多一次

  消息可能丢失 但不会重复

- 至少一次

  消息不会丢失 但可能重复

- 精确一次

  消息不会丢失 不会重复



**幂等生产者**

幂等性：一个函数执行一次和执行多次的结果是一样的 不会改变系统状态

幂等生产者局限性：

- 仅限于单分区
- 仅限于但会话：Producer进程重启就没了



**事务生产者**

能保证多分区 多会话之间的事务性 多个消息要么全部提交 要么全部不提交

但是会影响性能



