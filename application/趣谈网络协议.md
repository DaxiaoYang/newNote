[TOC]

# 趣谈网络协议



## 通信协议综述

### 为什么要学习网络协议



协议要素：

- 语法
- 语义
- 顺序



常用的网络协议：以下单过程为例

1. 浏览器中输入 https://www.kaola.com 

   DNS域名解析：域名 -> IP

2. 使用HTTP 封装请求  TLS加密

3. TCP封装

4. IP封装

5. 局域网内：想要发给网关 因为看到目的IP不在局域网内 ARP：网关IP -> MAC（IP是路由信息 用于远程定位 MAC是身份标识）

6. 路由器之间转发 同一个局域网内定位还是用MAC

7. 到达目的局域网 目的IP -> MAC

8. 到达目的机器后 解封包 进程收到http请求的内容 调用RPC通知其他处理具体业务的进程



### DHCP与PXE：IP怎么来的 又是怎么没的

**静态配置IP**：

需要配置：

- CIDR
- 子网掩码
- 广播地址
- 网关地址

```shell
$ sudo ifconfig eth1 10.0.0.1/24 # CIDR 不区分网络类型 只把IP分为两个部分 网络号和主机号
$ sudo ifconfig eth1 up


$ sudo ip addr add 10.0.0.1/24 dev eth1
$ sudo ip link set up eth1
```

IP不能乱配的例子：

16.158.23.6 -> 192.168.1.6

> 网络中跑的包 有上层就一定有下层

目的MAC地址 发现源IP跟目的IP不是一个网段 将包发送到网关 所以目的MAC地址是网关的MAC地址 而网关要跟当前网络的网卡是同一个网段的（同一个网段的才会使用ARP去拿MAC ARP有本地缓存 会先查缓存 缓存有固定大小和过期时间）



**DHCP**：动态主机配置协议 

> 解决的问题 静态IP配置麻烦 且客户端的机器使用的时间和地点都会变（连入公司wifi时 就需要给当前主机动态分配一个IP 租期使用完 如果没有续租就收回）

操作：配置一端共享的IP地址 当成IP池



工作方式：

1. DHCP Discover:只知道自己MAC地址 广播

   > UDP相较于IP就多了 
   >
   > 1. 端口号（用于转发到具体的应用）
   > 2. 包的校验和（数据正确性）

   ![image-20230529082052648](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202305290820760.png)

2. DHCP Offer：DHCP Server虽然知道申请机器的MAC地址 但是该机器当前还没有IP地址 所以还是只能用广播

   ![image-20230529082448074](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202305290824107.png)

3. DHCP request：从多个DHCP offer中选择一个（一般是最快到达的） 还是广播

4. DHCP ACK：接受客户机的选择 还是广播 让大家都知道



**IP地址的收回与续租**

客户端在租期50%的时候 再次发送DHCP request 

从对应的ACK包中获取新的租期和其他TCP/IP参数



**预启动执行环境**：PXE

> 解决的问题：对几百台空的机器 让他们自动安装操作系统 然后自动分配IP

设计：DHCP Server在分配给PXE客户端一个IP地址时 也同步给它PXE服务器的地址 启动文件名称（通过TFTP取文件）





## 底层网络知识详解：从二层到三层



### 从物理层到MAC层

> 如何在宿舍里自己组网玩联机游戏



**第一层：物理层**

两个电脑：

1. 两个电脑连网线 使得物理层的信号能收到
2. 配置IP 子网掩码 默认网关 配置成一个网络
3. 这样就形成了一个局域网



三个电脑：

集线器（Hub）：在物理层工作 将收到的每一个字节都转发到其他端口上（因为识别不了MAC地址 所以只能无差别广播）



**第二层：数据链路层**

如果只有hub 物理层会带来一些问题：

- 包是发给哪个机器的 哪个机器应该接收
- 大家都在发会产生混乱 有没有谁先发 谁后发的规则（信道就只有一个）
- 发送的过程中包出现错误怎么办



解决方法：

- 每个机器都有唯一的MAC地址 在MAC层加上源MAC地址和目的MAC地址 

  是自己MAC地址的包就接收 往协议栈上方传递

  解包实际上移动偏移量即可

- 多路访问：类比管理车流

  - 信道划分：分成多车道
  - 轮流协议：单双号出行
  - 随机接入协议：有时先出去 发现很堵 就回去 错峰出行

- MAC帧尾部加CRC 异或算法来检测



**局域网**

Hub的问题：

机器数量增多时 因为无条件广播数据 共享信道产生冲突的概率会提高

解决方法：

通过学习 记住每个端口出去对应的机器的MAC地址

-> 交换机 维护一个有过期时间 自学习的转发表

学习方式：MAC1的帧从A口流入 那MAC1的帧后续就应该转发到A口



> RARP：MAC -> IP
>
> 使用场景：
>
> 无盘机器 无法持久化IP地址到本地 但是有网卡 
>
> 在RARP服务器上配置MAC -> IP的映射
>
> 通过RARP获取IP
>
> 现在一般使用BOOTP(DHCP的前身 IP与MAC强绑定)或者DHCP



### 交换机与VLAN

场景：办公室 多台交换机



多台交换机带来的问题：环路

1 -> 2 需要通过ARP知道MAC地址

A和B的左口都接收到了ARP广播 并将其转发到右边的口

右边又是同样的情况 A和B的右口都接收到了那个包

这样A和B一直无法学习成功

![](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202306010549230.jpg)



**STP**：Spanning Tree Protocol

思想：破除图中的环 让最后的拓扑结构成为一棵树

设计：

1. 先给所有交换机分配一个包含优先级信息的ID 大家都是掌门
1. 互相比较自己掌门的优先级 加入优先级高的门派
1. 门派之间合并 最后只剩下一个门派 一个掌门



**广播问题与安全问题**

- 广播：交换机也有广播的问题 虽然会自学习
- 安全：包会在整个局域网中传输

解决方法：

- 物理隔离：

  一个部门一个子网 一个交换机

  部门之间得通过路由器

- 虚拟隔离：VLAN 虚拟局域网

  在MAC帧元信息中添加的TAG TAG中有VLAN ID

  交换机在把二层的头取下来的时候 识别到VLAN ID

  只有相同VLAN ID的包 才会互相转发

  交换机之间通过Trunk口连接 它会转发任何VLAN的口

  ![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202306010616524.jpg)

  ![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202306010617036.jpg)





### ICMP与ping

ping用到了ICMP查询报文：请求和响应

![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202306020636002.jpg)

相对于原生的ICMP多添加的东西：

- 标识符：定位组
- 序号：确定丢包
- 时间戳：计算RTT

```shell
# ICMP echo request
192.168.31.18 > 94.56.204.221.adsl-pool.sx.cn: ICMP echo request, id 50748, seq 0, length 64
06:59:32.886340 IP (tos 0x0, ttl 54, id 34043, offset 0, flags [none], proto ICMP (1), length 84)

# ICMP echo reply
94.56.204.221.adsl-pool.sx.cn > 192.168.31.18: ICMP echo reply, id 50748, seq 0, length 64
06:59:33.873210 IP (tos 0x0, ttl 64, id 17806, offset 0, flags [none], proto ICMP (1), length 84)
```



traceroute利用了ICMP差错报文：

1. 发送TTL = 1 2 3 4... 的UDP报文
2. 中间路由收到TTL = 0的报文 向源站发送ICMP时间超时
3. 这样就能定位到到达目的主机 中间经过的路由器

```shell
 # TTL 从1开始的UDP报文
 192.168.31.18.56231 > 110.242.68.4.33435: [udp sum ok] UDP, length 24
07:15:10.158411 IP (tos 0x0, ttl 1, id 56233, offset 0, flags [none], proto UDP (17), length 52)
    
07:15:10.164583 IP (tos 0x0, ttl 2, id 56235, offset 0, flags [none], proto UDP (17), length 52)

07:15:10.218314 IP (tos 0x0, ttl 3, id 56239, offset 0, flags [none], proto UDP (17), length 52)

# 中间路由 -> 源主机 时间超时ICMP差错报文 后面会跟上出错的IP包的IP头（20B）和IP正文前8B(包的UDP)
61.148.174.145 > 192.168.31.18: ICMP time exceeded in-transit, length 36
	IP (tos 0x0, ttl 1, id 57715, offset 0, flags [none], proto UDP (17), length 52)
    192.168.31.18.57706 > 110.242.68.3.33443: UDP, length 24
```





### 出网关

场景：宿舍连外网

方案：

- 再买一个网卡 

  同一个电脑上 一个网卡接到校园网的网口 另一个网卡接到宿舍的交换机上

- 买一个家庭路由器

  外网网口插到校园网网口 内网网口连上宿舍的所有的电脑

然后配置**网关**为两个网卡的电脑或者路由器

> 路由器：
>
> 三层设备 把MAC头和IP头都取下来 然后根据里面的内容 看看把包往哪里转发的设备
>
> 
>
> 网关与路由器
>
> 网关是某个局域网的出口地址
>
> 路由器由多个网关组成 不同的网口就是不同局域网的网关



**网关转发**：

决定从哪个网口转发出去：路由规则：

- 静态路由：配置
- 动态路由

**网关类型**：

- 转发网关：不改变IP地址

- NAT网关：

  改变IP地址 需要将内网地址转变为路由器出口的外网地址

  NAPT：内网IP:端口号 - 外网地址:端口号





### 路由协议

路由表：路由器接收到一个入口的网络包时 决定将包转发到哪个出口的转发信息库

路由表表项：

- 目的网络
- 出口设备
- 下一跳网关

```shell
# 10.176.48.0/20 目标网络
# eth0 出口设备
# 10.173.32.1 下一跳网关
ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0
```



**静态路由**

- 根据目的IP地址来配置路由

- 策略路由：根据多个参数：

  - 目的IP
  - 源IP
  - TOS（IP包优先级）
  - 入口设备

  应用场景：

  ![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202306120800581.jpg)

  租户A只想用慢速网络

  ```shell
  # 新建一个名为chao的路由表
  echo 200 chao >> /etc/iproute2/rt_tables
  
  # 源IP为这个的使用新路由表
  ip rule add from 192.168.1.101 table chao
  ip rule ls
  0:  from all lookup local 
  32765:  from 10.0.0.10 lookup chao
  32766:  from all lookup main 
  32767:  from all lookup default
  
  # 路由表中添加规则 默认网关为慢速网络的网关
  ip route add default via 60.190.27.189 dev eth3 table chao
  ip route flush cache
  ```



**动态路由算法**：

- 距离矢量路由 基于Bellman-Ford

  思路：

  每个路由器都保存一个路由表 都是知道全局信息 到目的路由器应该从哪个口出去 路径是多长

  适用于小型网络 小于15跳

  问题：

  - 好消息传得快 坏消息传得慢

    节点的加入很快就能知道

    节点的宕机要直到超过距离阈值才知道

  - 每次发送交换的都是全局路由表（全量传播）

- 链路状态路由 基于Dijkstra

  思路：

  每个路由器都将自己与相邻的路由的距离广播出去

  所以每个路由器都可以构建一个完整的图

  在图中找到两点之间的最短路径

  好处：

  - 增量传播：值广播更新的信息
  - 坏消息收敛快（收敛指所有路由的信息都一致）一个路由器挂掉了 它的邻居会广播这个消息



**动态路由协议**

- OSPF：

  用于数据中心内部 基于链路状态

  可以发现多个最短路径（等价路由） 从而做负载均衡

- BGP

  对距离矢量路由的改进 知道了路径 可以避免坏消息传得慢的问题 

  自治系统数量有限

  

## 传输层

### UDP

**建立连接的含义**：

在客户端与服务端双方都建立**数据结构**来维护双方交互的状态 

UDP相当于一个无状态的服务



**UDP特点**：

- 沟通简单：默认网络通畅 包不容易丢失
- 轻信他人：谁都可以传递数据给监听端口
- 不懂权变：不会根据网络拥塞情况 进行发包的拥塞控制



**UDP使用场景**

- 网络情况好的内网 需要资源少 对丢包不敏感的应用

- 需要广播或多播的应用

  > 多播：机器进程监听某个组播地址时 发送IGMP包 注册到所在网络的路由器上 后续路由器收到目的地址为这个组播地址时 就会把包转发给机器

- 需要处理速度快 时延低 网络拥塞时可以容忍少数丢包的情况

> RUDP和QUIC



**基于UDP的例子**

- QUIC：

  在应用层实现快速连接建立 减少重传时延 自适应拥塞控制

  > 为了解决HTTP在移动互联网中的问题：
  >
  > - TCP建立连接需要的时间长
  > - 移动中 TCP会断开重连 耗时长
  > - HTTP1.1 多个HTTP请求共享一个TCP连接 HTTP请求之间不是并行的

- 流媒体的协议

  直播场景

  - 实时性重要 宁可丢包也不要卡顿 老的视频帧就算重传过来了 用户也不在意了 
  - 丢帧不可避免的情况下 隔几个帧丢一个 看视频的人不会感知 
  - 网络拥塞的时候 应用层应该马上重传 而不是主动降低发送速度

- 实时游戏

- 物联网

  UDP占用内存资源少 **Thread协议**

- 移动通信领域

  GTP-U协议



### TCP

**TCP的关键点**：从TCP包头可以看出

- 顺序问题：seq
- 丢包问题：ack
- 连接维护：状态位
- 流量控制：窗口大小
- 拥塞控制：自身算法



**TCP三次握手**

为什么要三次握手：

- 两次握手的问题 连接双方都需要一发一收才能确定连接建立了

  A->B 第一次握手的包（可能丢失也可能绕路 A会超时重发 这个不是问题）

  B收到后 发应答包 

  关键在于应答包也可能丢失 绕路 或者A挂掉了 所以此时B不能认为连接建立起来了 得收到ACK的ACK才能确认

- 四次握手的问题

  可以 但是多余了 双方已经一发一收了 增加握手不能增加可靠性

- 为了沟通TCP包的序号

  每个连接的起始序号都是一个取自一个随着时间递增的int

  避免上一次的连接中绕路的包 影响到了本次连接

  

 **四次挥手**

问题：

- A收到B对FIN的ACK后 B宕机 

  可以通过linux tcp_fin_timeout参数设置超时时间

- TIME_WAIT 设置为2MSL时间的原因：

  - A对B FIN的ACK 丢失 

    B再发FIN 此时A如果关闭连接 则B的这个连接就没法关闭了

    所以需要保证B重发FIN的时候 A还在

  - 让A等到B发送的包都消失 再空出端口来（虽然序号已经可以保证了上一个连接的包不影响本次连接） 

  > 超过2MSL的时间后
  >
  > A已经是CLOSED状态 此时再收到B重发的FIN 就会直接发送RST（终止连接并清除连接状态）





### 套接字



**基于TCP协议的Socket程序函数调用过程**

服务端：

1. bind 绑定IP和端口 

   IP对应一个网卡

   端口用于找到应用程序

2. listen：服务端进入了这个状态（有一个监听Socket）

   每个Socket都有两个队列

   - 三次握手完成的连接队列
   - 正在握手的连接的队列

3. accept：取出一个握手完成的连接



客户端：

服务端listen的时候  发起connect

三次握手成功后 内核为给这个客户端分配一个临时的端口

accept的时候会返回另外一个Socket（已连接Socket）



之后双方可以像读写文件一样read和write



![image-20230724081656658](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202307240816768.png)

> - 进程里面有个文件描述符数组 文件描述符是这个数组的下标
> - Socket中有两个队列：接收 和 发送队列 里面都是缓存的TCP包



**基于UDP的Socket程序函数调用**

客户端和服务端都只需要bind

sendto recvfrom 函数都可以传入IP和端口



**服务端如何接更多项目（客户端）**

> 想以最少的资源 服务更多客户端

服务端单个最大TCP连接数：

- 客户端IP *  客户端端口  2^48 （因为服务端IP和端口不可变）
- 文件描述符限制 ulimit
- 内存限制



方式：

- 将项目外包给其他子公司（多进程）

  父进程中处理监听Socket（在揽活）

  fork出的子进程处理已连接Socket（在干活）

  因为子进程会复制父进程的文件描述符列表 所以能拿到已连接的Socket的文件描述符 -> 会指向内核中的统一打开的文件列表

  子进程的文件描述符和内存页表都会复制一份

  ![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202307240900664.jpg)

- 将项目转包给独立的项目组（多线程）

  更轻量级：文件描述符列表 内存页表 都是共享的 只不过多了一个引用   只有task列表会新建一项（所以是最小调度单位）

  ![img](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202307240904609.jpg)

  C10K问题：一台机器有维护1万个连接 就要创建1万个进程/线程 单机操作系统资源不够

- 一个项目组支撑多个项目（IO多路复用 一个线程维护多个Socket）

  fd_set就是项目进度墙

  在某个线程中用select 监听文件描述符集合是否有变化 然后对有变化的进行读写

- 一个项目组支撑多个项目（IO多路复用 从派人盯着 到有事通知）

  select缺点：所有把所有项目都过一遍才知道进度（主动轮询）

  epoll：项目进度发生变化时 主动通知项目组（事件驱动）

  所有被监听的事件都放在红黑树节点里面

  内核会把发生变化的事件放到链表中 

  这样每次只需要遍历链表即可（链表中都是要处理的事件）



## 应用层

### HTTP

**HTTP2.0**

HTTP1.0缺点：

- 私密性：纯文本通信
- 并发性：
  - 非pipeline模式： 当上一个http响应到达后才能发送下一个请求
  - pipeline模式：不用等待上一个响应返回就可以发送下一个请求 但是会存在队首阻塞问题 在一个TCP连接上服务端是按序处理每个http请求的 一个没处理完（比如前一个http请求中有一个tcp包没到 就会一直等着） 就不会处理下一个
- 带宽：每次通信都需要携带完整的http的头



**HTTP2.0**：

- 二进制编码：请求 = 一个流（逻辑上的 帧中有stream id标识） = header帧 + data帧（可以是多个）

- 一个TCP连接中切分出多个流 流有优先级 服务端会优先处理优先级高的流的帧

  多个流的帧可以乱序发送 在服务端同一个流的帧会被重新组装起来



**QUIC**

> HTTP2.0 还是用的TCP
>
> TCP包有严格顺序 不相关stream之间的帧的TCP包会被互相卡住

- 自定义连接机制

  TCP是四元组标识的 移动互联网情况下 只要一个元素变化 都会导致重连进行三次握手

  QUIC用64位的随机ID标识 当IP或端口变化时 不需要重新建立连接

- 自定义重传机制

  计算RTT比较准确

- 无阻塞的多路复用

  一个QUIC连接上可以创建多个stream 

  但是基于UDP 一个连接上的多个stream没有依赖

- 自定义流量控制

  每个stream有自己单独的流量窗口 窗口大小更合理

  



### HTTPS

**加密**：

- 对称加密

  问题在于如何让双方约定好加密的密钥

- 非对称加密

  公钥可以传播出去 私钥接收方留着

  双方都要有自己的公钥和私钥

  发送出去时 用对方的公钥加密 这样只有对方用自己的私钥才能解密



**数字证书**：怎么确保公钥就是对应网站的

证书内容：公钥 所有者 发布机构 有效期

CA用自己的私钥给网站的公钥签名

从网站上首先获得一个证书，用CA的公钥解密后，获取网站的公钥



**HTTPS的思路**

用非对称加密传输对称加密的密钥，数据传输用对称加密

![image-20230812074140838](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308120741986.png)



重放问题：

- 时间戳：时效性
- 随机数：如何之前收到过服务器就会拒绝该请求



### 流媒体协议

视频：快速播放一连串的图片组成 一个张图片就是一帧

一张图片有像素组成 一个像素24bit

正常传输：30（1s 30帧） × 1024 × 768 × 24 = ... = 70,778,880B

所以需要对视频进行编码，压缩传输的数据



视频和图片的特点：（音视频编解码）

- 空间冗余：相邻像素是渐变的 中间部分可以用算法算出来
- 时间冗余：时间相邻的图片相似 可以根据已有图片预测
- 视觉冗余：可以丢失一些数据
- 编码冗余：哈夫曼编码 对出现概率高的像素值有较少的字节编码



**直播过程**

![image-20230814085934148](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308140859240.png)

**编码**：图片 -> 二进制流

帧类型：

- I：完整图片
- P：存储当前帧值与之前帧的差别
- B：存储当前帧和前后帧的差别





![image-20230814090557878](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308140905926.png)



视频编码：

视频由帧组成 帧由片组成 一个片对应一个NALU



**推流：**数据流从主播到流媒体服务器

RTMP协议 基于TCP 会拆分成Chunk进行传输



**拉流：**客户端从流媒体服务器拉数据

对NALU组成的帧进行解码 交给播放器播放





### P2P协议

场景：下载电影

- HTTP：慢

- FTP：控制连接 + 数据连接

  ​			主动模式：服务器主动去连接客户端端口 建立数据连接

  ​			被动模式：服务器暴露端口 让客户端连过来

问题：单一服务器的**带宽**问题



**P2P**

资源分散地存储在许多设备上 下载文件可以到peer中下 自己也需要提供其他人下载的功能 所以既有下载流量 也有上传流量（百度网盘也是）



种子文件：.torrent

- tracker URL：中心化的服务器

- 文件信息：

  文件结构 文件各个段的大小 文件各个段的哈希值（哈希的作用 校验数据正确性）

问题：tracker需要收集 资源 -> 所有者ip的映射 服务器故障之后 就无法正常工作了



**去中心化网络**：DHT

每个加入网络的人 需要保存一部分 资源 -> 成员 的映射



Kademila协议：

![image-20230818084339361](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308180843416.png)

每个DHT node存储一部分文件的索引 知道文件应该到哪个节点上找



问题：如何确定哪些文件索引由哪些节点保存

哈希值：

算出文件的哈希值 跟文件哈希值一样的node 就需要知道这个文件去哪里下载 如果不存在 则哈希值接近的N个结点也应该知道（低位不相同的）



工作方式：

1. 新节点想要下载文件1 
2. 加入DHT网络：从.torrent文件中找到一个DHT node
3. 计算文件1的哈希值 询问对应nodeC的地址 被问到的 不知道的话继续问 
4. node C 告诉node new 要下载文件1 就去B D F节点
5. 从B节点下载成功后 自己本地也有文件1了 然后node new告诉node C以及和node C相近的节点 自己也有文件1了  文件拥有者列表更新



node ID相似：距离小 两个二进制的异或值

10和00的距离是异或值2



朋友圈的维护：

距离 -> 相同距离的node list



如何查找节点：

1. 算出距离
2. 到对应的node list中找 如果找不到 就随便取一个问（每取到一个 距离缩小一半 因为取到的节点 与目标节点 有一个位是相同的）







### DNS

DNS功能：

- 域名 -> IP地址

- 负载均衡（通过给域名返回不同的IP实现）



**DNS服务器**

场景：全世界的人都需要访问

所以得做成分布式 高可用 高并发的



**DNS解析流程**

1. 客户端 -> 本地dns缓存
2. 本地dns（这里也有缓存） 由电信 移动等网络服务商分配
3. 根dns给本地dns一个顶级dns的地址
4. 顶级dns给本地dns一个权威dns的地址
5. 权威dns 将域名对应的ip返回给本地dns（不做全局负载均衡的情况下）
6. 做全局负载均衡的情况下：权威dns返回一个域名 让本地dns去请求gslb解析域名（权威DNS是公司自己维护 本地DNS是运营商维护）

![image-20230821082317878](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308210823009.png)



**负载均衡**

> k8s中很多负载均衡都是通过域名做的

DNS的负载均衡类型：

- 内部负载均衡：对同一个集群内的多个实例的流量进行均衡

- 全局负载均衡：对不同地域的集群的流量进行均衡（考虑运营商 地区等）





### HttpDNS

**传统DNS的问题**（主要是本地DNS无法定制的问题）

- 域名缓存（缓存一定会有的问题 缓存不一致） 解析速度与更新速度之间的tradeoff

  IP过期失效 缓存还没更新

  本地DNS还会缓存静态页面

  全局负载均衡失效

- 域名转发问题

  本地DNS将解析请求转发给其他运营商的DNS 

  会返回给客户端 其他运营商的IP地址 导致访问慢

- 出口NAT问题

  出口后IP地址会转换 有可能导致权威DNS判断不出运营商

- 域名更新问题

  权威DNS服务器解析变更的结果 在全网真正生效的周期很长

  双机房部署服务 用DNS做跨机房的负载均衡和容灾的时候 一个机房出问题后 修改权威DNS 将域名指向新Ip地址

  如果本地dns更新太慢 那很多用户还是会访问到原来有问题的ip

- 解析延迟问题

  传统dns查询过程需要访问多个层级的dns服务器 会带来一定的时延



**HttpDNS**

- 工作模式

  前端：

  在自己的手机应用中嵌入支持httpDNS的客户端sdk 这样解析域名的适合 首先访问的是sdk中的缓存 请求也是sdk向自己搭的后端httpDNS服务请求

  后端：

  搭建自己的基于http协议的dns服气集群 分布在多个地点和多个运营商

  ![image-20230821085645871](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308210856908.png)

- 缓存设计

  之前的缓存在本地dns服务器中 无法定制

  现在缓存是在sdk的缓存中 过期 更新策略都可以自己控制

  缓存涉及的组成：客户端 - 缓存 - 数据源

  缓存更新策略：

  - 同步更新：cache-aside

    缓存没命中的时候  就去请求 将请求到的记录更新到缓存 再返回

    优点：实时性好

    缺点：如果有多个请求都发现过期 会请求httpDNS多次

  - 异步更新：refresh-ahead

    缓存没命中时 添加一个解析任务到后台 由后台任务调用httpDNS的接口 接口回调中更新缓存

    优点：多个请求都发现缓存过期时 可以合并为一个httpDNS的请求任务  可以在即将过期时 先发起任务 进行预加载（数据预热）

    缺点：需要容忍客户端拿到过期数据的情况

- 调度设计

  客户端：

  知道地位位置和运营商

  反馈各个服务节点的网络情况

  服务端：

  配置不同节点的优先级

  



### CDN

对比电商存储就近配送的思路 会提前把要卖的货物放在离用户进的各区域仓库里面

CDN分发系统架构：边缘节点找不到则往上层找 越往上走 缓存的数据越多

- 中心节点
- 区域节点
- 边缘节点

![image-20230825083117439](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308250831551.png)





问题：客户端如何找到最近的边缘节点 

利用DNS域名解析

权威dns web.com -> 返回cdn的权威dns地址 web.cdn.com给本地dns

本地dns请求cdn的权威dns 

cdn的权威dns会让本地dns再去访问cdn的全局负载均衡器(gslb)

glsb选择cdn节点ip的依据：

- 用户ip地址 判断距离
- 用户运营商
- 用户请求的url上的内容 判断哪个cdn节点上有
- 判断各个节点的负载

如果返回的cdn节点上没有用户所需请求的内容 则这个cdn节点就要向上一级节点请求内容（上一层也是这么处理）

![image-20230825083138760](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202308250831797.png)





**cdn中缓存的内容**

- 静态资源

  - 静态页面 内容一般是被被动的拉取 未命中则回源拉取

  - 流媒体 数据量大 回源压力大 所以采用主动推送的方式 主动将热点数据推送到边缘节点

    同时cdn还会预处理流媒体数据 将视频转码（不同清晰度）

    同时需要考虑防盗链 否则视频会在其他网站上播放 

- 动态数据

  - 边缘计算：定时从源数据从同步数据 然后由边缘节点计算出来
  - 路径优化：动态数据在源站生成 然后下发到边缘节点 通过cdn加速网络下发（调整tcp参数使得更激进传输）



### 数据中心

**服务器**：

放在机架上



**Top of Rack交换机**：

每个机架上面都有一个交换机（Top of Rack），用于机架内服务器的通信



**汇聚交换机**

将不同机架连接



**核心交换机**

连接不同可用区

![image-20230905082146658](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202309050821713.png)



数据中心的机器越来越多后：

核心交换机以下都是二层互联的（一个广播域 就是一个局域网）

![image-20230905082640550](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202309050826607.png)



**边界路由器**

连接外网和核心交换机





**高可用**

- 服务器与TOR之间 双网线和网卡
- TOR高可用：堆叠
- 汇聚交换机高可用：堆叠
- 核心交换机高可用：堆叠



TRILL：多连接透明互联协议：

思想：将三层的路由能力在二层模拟实现



### VPN

背景：

公司多个内网之间怎么互联

解决方案：

- 走公网：不安全
- 租用专线：贵
- vpn：折中 安全又不贵



vpn：虚拟专用网，利用公共网络 建立专用的数据传输通道



**vpn工作原理**

隧道技术

![image-20230917144634221](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202309171446362.png)

车从广东到海南

- 乘客协议：开车规则
- 隧道协议：轮渡里排列好车
- 承载协议：轮船航行规则



**IPsec VPN**

- 私密性：使用对称密钥进行加密
- 完整性：hash数据摘要
- 真实性：身份认证 
  - 预共享密钥：双方约定一个暗号
  - 数字签名：如果能用公开的数字签名中的公钥 解开私钥加密的内容 就说明对方是对方



建立过程：

1. 计算出一个对称密钥K

2. 每隔一段时间 生成一个对称密钥M 用K加密传递

   实际数据加密使用M



> IP网络的问题：路由查找多 效率差
>
> ATM技术：面向连接（跟IP一个层） 形成一个虚拟的通路 连接建立后 所有的包都按相同的路径走 免去了路由查找的时间
>
> MPLS：多协议标签交换技术 在原始的IP外 多了MPLS的头 可以打标签 进行快速的包转发





### 移动网络

移动网络发展：

- 2G

  手机通过无线信号连接基站

  基站前接无线 后接核心网

  核心网前接基站请求 判断请求合法且有钱后 后接网关 连接电话网络

- 2.5G

  开始支持IP网络

- 3G

  无线通信进步 无线带宽增加

- 4G

  无线下行带宽达到百兆级别

  核心网：控制面与数据面分离 因为他们需要处理的数据包大小不同

![image-20230919200659603](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202309192006718.png)

> HSS：存储号码归属地 认证信息
>
> MME：根据HSS的信息 进行合法性判断
>
> SGW和PGW：负责具体转发数据包 SGW是本地运营商 PGW是所属运营商
>
> PCRF：流量计费



SCTP：eNodeB与MME之间的传输层

- 多宿主：一个连接可以使用多个网卡 达到高可用
- 多个流：一个连接中多个流（类似http2的stream）
- 四次握手 防止SYN攻击：TCP中 服务端收到SYN后 就需要建立数据结构 并记录下状态 SCTP 先走INIT和INIT-ACK 然后才创建数据结构
- 消息分帧：保证对端读出的数据大小与此相同
- 三次挥手：一端关闭 对端也要关闭



**异地上网问题**

国内手机卡在国外使用：

国外MME查询国内运营商的HSS

国外SGW转发到国内PGW

![image-20230919202232832](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202309192022868.png)





## 云计算中的网络

**数据中心的问题**

不灵活：

- 采购
- 运维：硬件扩缩容
- 规格：机器配置过大
- 复用：给另外用户用 需要重装操作系统



虚拟机：云计算技术



**虚拟网卡原理**：

应用的网络包 -> 字符设备文件 -> 虚拟网卡驱动 -> 协议栈 -> 虚拟网卡



**虚拟网卡连接到云中**

问题：

- 共享：多个虚拟网卡如何共享同一个物理网卡
- 隔离：流量不被物理机上的其他用户窃听 流量不会被其他用户过期挤占
- 互通：相同或不同物理机上的虚拟机之间如何通信
- 灵活：配置



**共享与互通**

一台物理机上的虚拟机如何互联：虚拟网桥 同属一个子网

虚拟机如何连接外网：

- 桥接：

  每个虚拟机的虚拟网卡 和物理网卡 都连接到虚拟交换机上

  包都通过物理网卡出来连接到物理交换机上

  都在一个二层网络中 会有广播问题（可以用VLAN切割）

- NAT

  虚拟机网卡和物理网卡是两个子网

  虚拟网卡 -> br0（虚拟网桥） -> 路由器 -> NAT成为物理网络的地址 -> 物理网卡



**隔离问题**

- 同物理机内：

  通过设置VLAN的tag

- 跨物理机

  创建带VLAN的虚拟网卡



































