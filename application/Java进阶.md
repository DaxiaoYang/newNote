# Java进阶

[TOC]

# 直播课：



可靠性是指什么 接口级的

弹性边界：需要的实例数量

Entry





# 日常课

## 项目性能优化

### 性能影响因素

性能优化目标：**提升用户体验**，可分为产品和技术方面提升

- 产品层面：非技术 流程设计优化 

  比如火车抢票：

  - 客户端点了下单后 几秒内不能点第二次 避免重复请求 减少系统并发量
  - 不同的地方发票时间分散在全天 分散请求量

- 系统性能：响应时间快

  - 前端
  - 移动端
  - 后端：RT TPS 
    - 架构：缓存 反向代理
    - 逻辑处理：网络IO 逻辑计算复杂度 RPC   数据库读写
    - JVM：内存大小 GC（特别是Full GC）的频率和停顿时间

  > 1. 0-100毫秒：用户会感觉到立即响应，这是最理想的情况。用户会感觉系统非常快速和流畅。
  > 2. 100-300毫秒：大多数用户可以感觉到稍微有一点延迟，但仍然会感觉到系统的响应速度良好。
  > 3. 300-1000毫秒：用户开始感觉到明显的延迟，会有一种稍微的卡顿感。这可能会对用户体验产生一定的影响，但在某些情况下仍然可以接受。
  > 4. 1000毫秒以上：用户会明显感觉到延迟，并且开始感到不耐烦。这可能导致用户的不满和流失，特别是对于需要频繁交互的应用程序



**影响性能的点**

- 产品设计：比如可以分批/延迟加载页面
- 移动端环境
- 基础网络：网络 = 连接介质 + 终端 一般海外环境需要考虑
- 硬件及云服务：服务器的CPU 内存 磁盘 网卡
- 架构和代码质量（当前关注的点）



**压测指标**

- RT：一般看P99值
- TPS
- 资源利用率：CPU 内存 网络IO

![image-20231226082948428](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202312260829554.png)

> 最优并发用户数：轻负载区和重负载区的边界 资源利用率已经差不多满了 但是RT并没有很高
>
> 最大并发用户数：重负载区和塌陷区的边界 再增加用户 RT涨的很快 会影响用户体验了





### 调优手段

**服务容器优化**

- Tomcat配置优化

  > Tomcat对请求的处理模型为
  >
  > nio(linux epoll 8.0.24后使用)处理传输层请求 + 线程池

  - 最大线程数（应用层） 

    对请求进行业务处理的线程池 默认200

    经验：1C2G 200 以此类推

    设置过高的弊端：

    - 性能：线程上下文切换会带来性能消耗
      - 运行环境的保存与恢复（CPU各种寄存器的值）
      - 涉及系统调用 应用态-内核态的切换
      - 当前线程CPU缓存失效（因为切了新线程了 数据缓存和指令缓存都更有可能失效）
    - 内存：每个线程 会占Xss（默认1M）的内存
  
    > 设置因素：
    >
    > 计算任务类型：CPU密集/IO密集型
    >
    > CPU密集型：线程数=CPU核数 
    >
    > IO密集型：可以通过调高线程数获取更大并发 一般业务中的IO都是同步阻塞的（RPC/读写数据库）所以线程运行中会有挂起的情况 不会一直占着CPU 
  
    
  
  - 最大连接数（TCP层）
  
    服务端最多与多少客户端建立TCP连接
  
  - 最大等待数（TCP层）
  
    当连接数达到最大连接数后 有多少连接请求可以在队列中等待
  
    ```shell
    yum install net-tools
    # 看所有监听连接的socket
    netstat -anpt | grep -i "listen"
    
    # 看所有socket
    netstat -anpt
    ```
    
    ![image-20231226092438651](https://daxiao-img.oss-cn-beijing.aliyuncs.com/img/202312260924694.png)

- 网络IO模型优化

  nio -> nio2(aio) 持疑 因为Java中还是用nio去模拟实现aio

- 换Web容器（Servlet容器）

  换成Undertow （Jetty也会快一点）



**数据库调优**

- 逻辑：

  - 表结构：索引 + SQL配合不是很好
  - 大表：扫描行多
  - 大事务：加锁时间长？
  - 数据库架构：分库分表 读写分离（主库写 从库读） 

- 物理：

  数据库所在服务器硬件



**OpenResty调优**

就是nginx反向代理+多实例



**多级缓存调优**

离用户越近 缓存价值越大 （因为网络传输成本越小）

> 客户端/浏览器缓存
>
> > cdn缓存（传输距离）
> >
> > > 反向代理服务器缓存
> > >
> > > > 服务内存缓存
> > > >
> > > > > 分布式内存缓存
> > > > >
> > > > > > 数据库



**JVM调优**

目的：最小的硬件成本 -> 最大的吞吐量

- 内存
- GC暂停时间（过长会影响RT的P99值）



需要调优的场景：

- OOM
- Full GC频繁
- GC停顿时间过长（超过1s）



调优手段：

- 内存分配：整体 + 不同区的比例
- 垃圾回收器选型









