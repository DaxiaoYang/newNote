# C++

[TOC]

## C++ Primer

### C++基础



#### 变量和基本类型

向输出流写入数据

```C++
// 1. << 运算符返回的结果是其左侧对象 即ostream对象
// 2. std::endl效果：结束当前行 并将内存缓冲刷到设备上
std::cout << "output" << std::endl;
```



变量声明与定义：

- 声明：只定义变量类型和名字 不分配内存空间

  `extern int i;` 

- 定义：既定义变量类型和名字 同时也分配内存空间

  `int i`



引用与指针：

- 引用：

  语义：给一个变量起别名

  本质：是一个常量指针，编译器提供的语法糖

  ```c++
  int a = 10;
  int &ref = a; // <==> int * const ref = a;
  ref = 30; // <==> *ref = 30;
  ```

  必须被初始化 与一个已经存在的对象绑定 对引用的操作 就相当于对被绑定的对象的操作 并且不能重新赋值

  ```c++
  int i = 1024;
  int &refI = i;
  // 就相当于 i = 1;
  refI = 1;
  ```

- 指针：

  一个存储内存地址的变量（对象）



const：创建后值不能改变的变量 必须被初始化

- 多文件共享：extern声明

- const引用(常量引用)：不能修改引用绑定的对象 多用于传参

- 指针：

  - pointer to const：类似于常量引用 不能改变所指对象的值

    ```c++
    int i = 1;
    const int *p = &i;
    ```

  - const pointer：指针值不变

    ```C++
    int i = 0;
    int *const p = &i;
    ```

- 分类：

  - 顶层const：指针自身是一个常量
  - 底层const：指针所指的对象是一个常量

- 常量表达式：编译时得到计算结果 且值不会改变的表达式

  constexpr由编译器验证变量是否为常量表达式



处理类型：

- 类型别名

  ```c++
  // 将double 取一个salary的别名
  typedef double salary;
  // 同样的效果
  using salary double;
  ```

- auto：让编译器通过初始化时使用的表达式来分析出变量的类型

  ```c++
  int i = 0, j = 1;
  auto k = i + j;
  ```

- decltype：从表达式中分析出类型 但是不用这个表达式来初始化变量 也不计算表达式

  ```c++
  decltype(sum()) num = x;
  ```




**类型转换**

隐式类型转换：

- 表达式中 整型会转成字节数较大的整型
- 条件中 非布尔值会转换成布尔类型(非0 -> 0->0)
- 初始化或者赋值的时候
- 函数调用的时候

其他隐式类型转换：

- 数组转成指针

  ```c++
  int array[10];
  int* nums = array;
  ```

- 指针的转换

- 转成bool

- 非常量的指针/引用 -> 常量类型的指针/引用（反之则不行）

- 类类型定义的转换 

  ```c++
  // 将istream类型 转成了 bool类型
  while (cin >> s)
  ```

  

算术转换：

- 整型提升：将小整数转换成字节数大的大整数
- 无符号类型：unsigned int + int => unsigned int（注意int为负数时的影响）前提是unsigned类型的字节数>= 带符号类型的字节数



显示转换：`cast-name<type>(expression)`

cast-name类别：

- static_cast 普通强制类型转换 大转小

- const_cast 强制去掉const

  ```c++
  const char* pc;
  char* p = const_cast<char*>(pc);
  ```

- reinterpret_cast 转换位模式的解释

  ```c++
  int* ip;
  char* pc = reinterpret_cast<char*>(ip);
  ```

  





## C++视频

### 基础

**函数**

函数分文件编写步骤：

1. 创建.h头文件 `swap.h` 并在其中写函数声明

   ```c++
   void swap(int &a, int &b);
   ```

2. 创建.cpp源文件 `swap.cpp` 并在其中写函数定义

   ```c++
   #include "swap.h"
   
   void swap(int &a, int &b) 
   {
     	// ....
   }
   ```

3. 其他文件使用时 `include "swap.h"` 即可

​	

**指针**

const修饰指针

```c++
// 1. 不能通过p修改其指向的内容 但是可以修改指针指向的位置
const int *p = 12;
// 2. 可以通过p修改其指向的内容 但是不能修改指针指向的位置
int * const p = 12;
// 3. 两个都不能改
const int * const p = 12;
```



**结构体**

```c++
// 定义
struct Student 
{
  	string name;
  	int age;
};

// 使用
Student s = {"daxiao", 18};
s.name = "daxiao2";

Student *p = &s;
p->age = 20;

// 其指针作为函数参数时 配合const 可以保护所指对象不被修改
void print(const Student *p)
{
  // 报错
  	p->age++;
}
```



### C++核心编程

**内存分区模型**：

编译后运行前存在的：代码区 全局区

运行后存在的：栈区 堆区

- 代码区：

  存放函数的代码(CPU的机器指令) 由操作系统管理

  特点：

  - 共享：多次执行同一个可执行文件 代码区在内存中只会维护一个（享元模式）
  - 只读：为了防止指令被意外修改

- 全局区：

  存放全局变量 静态变量以及常量：字符串常量和全局常量

  程序结束运行后 由操作系统释放

- 栈区：由编译器自动分配和释放 函数调用完回收 存放函数的参数和局部变量 **所以需要注意不要返回局部变量的地址到函数外部或其他地方 如lambda表达式中**

- 堆区：由程序员分配和释放 如果不释放 在程序结束时由操作系统释放

划分进程内存不同区域的目的，因为不同对象的变量的生命周期不同，同一生命周期的变量需要放在一起管理，提高内存利用率（划分变与不变 尽早释放内存）



**引用**

语义：给一个变量起别名

本质：编译后就是一个常量指针，编译器提供的语法糖

```c++
int a = 10;
int &ref = a; // <==> int & const ref = a;
ref = 30; // <==> *ref = 30;
```

 常量引用：主要作用是为了不让函数内的操作修改引用对象的值

```c++
void print(const int &val) // const int * const val  所以不能修改形参的指向 也不能修改指向的值
{
  	// 避免误操作修改val的值
}
```

注意事项：

- 引用必须被初始化 即必须指向一个内存地址
- 引用不能改变指向的地方
- 不要返回局部变量的引用（跟不要返回局部变量的指针一个道理 因为栈会自动被释放）
- 引用可以作为左值（即可被赋值）





####  模板

> 将类型参数化 
>
> 不变：处理逻辑
>
> 变化：参数类型

分类：

- 函数模板
- 类模板



**函数模板**

可以为函数的形参和返回值指定一个泛型

```c++
template<typename/class T>
T func(T t);
```

使用模板时指定参数的方式：

- 自动类型推导
- 显示指定类型 <指定的类型>



注意事项：

模板必须要确定出一致的T的数据类型后才可以使用



**函数默认参数**：

1. 默认参数声明和实现都可以定义 但是不能同时定义 最好还是在声明定义
2. 只能在最右边定义









